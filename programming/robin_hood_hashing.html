<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="shortcut icon" href="/dist/favicon.ico">
    <link rel="apple-touch-icon" href="/dist/favicon.png">
    <link rel="stylesheet" type="text/css" href="/dist/highlight.css">
    <link rel="stylesheet" type="text/css" href="/dist/katex.min.css">
    <link rel="stylesheet" type="text/css" href="/dist/main.css">
    <title>Robin Hood Hashing 源码分析 | SF-Zhou's Blog</title>
  </head>
  <body>
    <div class="app">
      <div class="title">
        <h1> Robin Hood Hashing 源码分析 </h1>
      </div>
      <div class="info">
        <div class="date"> 2021.05.21 </div>
        <a href="https://github.com/SF-Zhou">
          <div class="author"> SF-Zhou </div>
        </a>
      </div>
      <div class="markdown">
        <p>从 C++11 开始，STL 会提供哈希表 <a href="https://github.com/martinus/robin-hood-hashing"><code>std::unordered_map</code></a> 的实现，用起来确实很方便，不过性能上就差强人意了。<a href="https://github.com/martinus/robin-hood-hashing"><code>robin_hood::unordered_map</code></a> 作为 <code>std::unordered_map</code> 的替代品，提供了与标准库中一致的接口，同时带来 2 到 3 倍的性能提升，着实让人心动。笔者年前尝试使用该哈希表，但由于其<a href="https://github.com/martinus/robin-hood-hashing/issues/21">内部的 Bug</a> 导致低概率的抛出异常，不得已又退回使用标准库。今年 3 月底的时候其作者<a href="https://github.com/martinus/robin-hood-hashing/pull/121">修复了该 Bug</a>，笔者也第一时间测试使用，并上线到现网环境，截止目前无任何故障。安全起见，笔者分析了该哈希表的具体实现，分析的代码版本为 <a href="https://github.com/martinus/robin-hood-hashing/blob/3.11.1/src/include/robin_hood.h">3.11.1</a>，目前也没有发现潜在的安全隐患。依笔者之见，Robin Hood 高性能的秘诀是开放寻址、平坦化和限制冲突。</p>
<h3 id="1.-开放寻址" tabindex="-1"><a href="#1.-%E5%BC%80%E6%94%BE%E5%AF%BB%E5%9D%80">1. 开放寻址</a></h3>
<p>目前主流的 STL 实现均使用闭式寻址（Closed Addressing），当发生冲突时，需要使用额外的数据结构处理冲突。例如 GCC 中使用的是链表，查询时会先对 key 进行哈希确定桶的位置，再比对桶对应的链表中的元素。闭式寻址的优势是删除简单，相同负载系数下对比开放寻址性能更好。但冲突剧烈时，查询的复杂度也会从 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></eq> 退化到 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq>，此时也依赖 Rehash 减少冲突。</p>
<table>
<thead>
<tr>
<th>Bucket</th>
<th>Collision Chain</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td></td>
</tr>
<tr>
<td>1</td>
<td>①</td>
</tr>
<tr>
<td>2</td>
<td>②②②</td>
</tr>
<tr>
<td>3</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>④</td>
</tr>
<tr>
<td>5</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td></td>
</tr>
<tr>
<td>7</td>
<td>⑦⑦</td>
</tr>
</tbody>
</table>
<p>而 Robin Hood 中使用的是开放寻址（Open Addressing），发生冲突时会尝试找下一个空桶的位置，每个桶至多存放一个元素，这也就限制了其负载系数至多为 1。其优势是有更好的缓存局部性，负载系数低时性能优异，劣势是删除时复杂度更高，负载系数高时冲突剧烈。单纯使用开放寻址无法应对复杂的现实  需求，为了提高性能还需要额外的优化策略。</p>
<table>
<thead>
<tr>
<th>Bucket</th>
<th>Open Addressing</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>⑦</td>
</tr>
<tr>
<td>1</td>
<td>①</td>
</tr>
<tr>
<td>2</td>
<td>②</td>
</tr>
<tr>
<td>3</td>
<td>②</td>
</tr>
<tr>
<td>4</td>
<td>②</td>
</tr>
<tr>
<td>5</td>
<td>④</td>
</tr>
<tr>
<td>6</td>
<td></td>
</tr>
<tr>
<td>7</td>
<td>⑦</td>
</tr>
</tbody>
</table>
<h3 id="2.-平坦化" tabindex="-1"><a href="#2.-%E5%B9%B3%E5%9D%A6%E5%8C%96">2. 平坦化</a></h3>
<p>平坦化（Flatten）是指将哈希表中的元素直接存储在哈希桶数组中。非平坦化的实现会在哈希桶数组中存放元素的指针，查询时先读桶中的数据，再访问对应的元素，会产生一次间接寻址。平坦化则可以减少一次寻址操作，确定桶的位置后就可以直接访问元素。其优势自然是获得更好的性能和缓存局部性，劣势是需要使用更多的内存空间，以 80% 的负载系数为例，Rehash 后 60% 的内存空间存放的是空桶。另外平坦化要求键值对支持移动构造和移动复制，Robin Hood 对符合该条件并且键值对总大小小于 6 个 <code>size_t</code> 的会启用平坦化的实现：</p>
<pre class="language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">Key</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">Hash</span> <span class="token operator">=</span> hash<span class="token operator">&lt;</span>Key<span class="token operator">></span><span class="token punctuation">,</span>
          <span class="token keyword">typename</span> <span class="token class-name">KeyEqual</span> <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>equal_to<span class="token operator">&lt;</span>Key<span class="token operator">></span><span class="token punctuation">,</span> size_t MaxLoadFactor100 <span class="token operator">=</span> <span class="token number">80</span><span class="token operator">></span>
<span class="token keyword">using</span> unordered_map <span class="token operator">=</span> detail<span class="token double-colon punctuation">::</span>Table<span class="token operator">&lt;</span>
    <span class="token keyword">sizeof</span><span class="token punctuation">(</span>robin_hood<span class="token double-colon punctuation">::</span>pair<span class="token operator">&lt;</span>Key<span class="token punctuation">,</span> T<span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>size_t<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">6</span> <span class="token operator">&amp;&amp;</span>
        std<span class="token double-colon punctuation">::</span>is_nothrow_move_constructible<span class="token operator">&lt;</span>robin_hood<span class="token double-colon punctuation">::</span>pair<span class="token operator">&lt;</span>Key<span class="token punctuation">,</span> T<span class="token operator">>></span><span class="token double-colon punctuation">::</span>value <span class="token operator">&amp;&amp;</span>
        std<span class="token double-colon punctuation">::</span>is_nothrow_move_assignable<span class="token operator">&lt;</span>robin_hood<span class="token double-colon punctuation">::</span>pair<span class="token operator">&lt;</span>Key<span class="token punctuation">,</span> T<span class="token operator">>></span><span class="token double-colon punctuation">::</span>value<span class="token punctuation">,</span>
    MaxLoadFactor100<span class="token punctuation">,</span> Key<span class="token punctuation">,</span> T<span class="token punctuation">,</span> Hash<span class="token punctuation">,</span> KeyEqual<span class="token operator">></span><span class="token punctuation">;</span>
</code></pre>
<p>对于不符合条件的键值对，Robin Hood 中也提供了非平坦化实现。简单压测可以发现，相同的键值对类型平坦化相较于非平坦化可以提升一倍多的性能。</p>
<h3 id="3.-限制冲突" tabindex="-1"><a href="#3.-%E9%99%90%E5%88%B6%E5%86%B2%E7%AA%81">3. 限制冲突</a></h3>
<p>Robin Hood 中使用了 <code>uint8_t</code> 类型的 Info 字段记录 key 的目标桶与实际存放桶之间的距离，使用该字段实现：</p>
<ol>
<li>检查桶是否为空桶；</li>
<li>限制目标桶与实际桶之间的距离小于 256，使查询的复杂度收敛；</li>
<li>保证桶中实际存放的键值对的顺序始终与键值对目标桶的顺序一致。</li>
</ol>
<table>
<thead>
<tr>
<th>Bucket</th>
<th>Info=0</th>
<th>Info=1</th>
<th>Info=2</th>
<th>Info=3</th>
<th>Info=4</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>空</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1</td>
<td></td>
<td>①</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>2</td>
<td></td>
<td>②</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>3</td>
<td></td>
<td></td>
<td>②</td>
<td></td>
<td></td>
</tr>
<tr>
<td>4</td>
<td></td>
<td></td>
<td></td>
<td>②</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td></td>
<td></td>
<td>④</td>
<td></td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>空</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>7</td>
<td></td>
<td>⑦</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>8 (Buffer)</td>
<td></td>
<td></td>
<td>⑦</td>
<td></td>
<td></td>
</tr>
<tr>
<td>9 (Buffer)</td>
<td></td>
<td></td>
<td></td>
<td>⑦</td>
<td></td>
</tr>
</tbody>
</table>
<p>如上表所示，使用 Info=0 表示空桶，非空桶时 Info 记录键值对与哈希目标桶的距离，当超过限制时执行扩容。插入时根据距离判断键值对的目标桶位置并以此排序执行插入，删除时也根据该距离判断是否需要将键值对前移。申请哈希数组时至多会额外申请 0xFF 个空间存储尾端冲突的键值对。</p>
<p>执行插入的代码如下：</p>
<pre class="language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Args<span class="token operator">></span>
std<span class="token double-colon punctuation">::</span>pair<span class="token operator">&lt;</span>iterator<span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">emplace</span><span class="token punctuation">(</span>Args<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">ROBIN_HOOD_TRACE</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
  <span class="token comment">// 构造键值对节点</span>
  Node n<span class="token punctuation">{</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>Args<span class="token operator">></span></span></span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token comment">// 查询插入位置</span>
  <span class="token keyword">auto</span> idxAndState <span class="token operator">=</span> <span class="token function">insertKeyPrepareEmptySpot</span><span class="token punctuation">(</span><span class="token function">getFirstConst</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">switch</span> <span class="token punctuation">(</span>idxAndState<span class="token punctuation">.</span>second<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> InsertionState<span class="token double-colon punctuation">::</span>key_found<span class="token operator">:</span>
      n<span class="token punctuation">.</span><span class="token function">destroy</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>

    <span class="token keyword">case</span> InsertionState<span class="token double-colon punctuation">::</span>new_node<span class="token operator">:</span>
      <span class="token double-colon punctuation">::</span><span class="token keyword">new</span> <span class="token punctuation">(</span><span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mKeyVals<span class="token punctuation">[</span>idxAndState<span class="token punctuation">.</span>first<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token function">Node</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>

    <span class="token keyword">case</span> InsertionState<span class="token double-colon punctuation">::</span>overwrite_node<span class="token operator">:</span>
      mKeyVals<span class="token punctuation">[</span>idxAndState<span class="token punctuation">.</span>first<span class="token punctuation">]</span> <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>

    <span class="token keyword">case</span> InsertionState<span class="token double-colon punctuation">::</span>overflow_error<span class="token operator">:</span>
      n<span class="token punctuation">.</span><span class="token function">destroy</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">throwOverflowError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 返回迭代器</span>
  <span class="token keyword">return</span> std<span class="token double-colon punctuation">::</span><span class="token function">make_pair</span><span class="token punctuation">(</span>
    <span class="token function">iterator</span><span class="token punctuation">(</span>mKeyVals <span class="token operator">+</span> idxAndState<span class="token punctuation">.</span>first<span class="token punctuation">,</span> mInfo <span class="token operator">+</span> idxAndState<span class="token punctuation">.</span>first<span class="token punctuation">)</span><span class="token punctuation">,</span>
    InsertionState<span class="token double-colon punctuation">::</span>key_found <span class="token operator">!=</span> idxAndState<span class="token punctuation">.</span>second<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">OtherKey</span><span class="token operator">></span>
std<span class="token double-colon punctuation">::</span>pair<span class="token operator">&lt;</span>size_t<span class="token punctuation">,</span> InsertionState<span class="token operator">></span> <span class="token function">insertKeyPrepareEmptySpot</span><span class="token punctuation">(</span>OtherKey<span class="token operator">&amp;&amp;</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">256</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    size_t idx<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    InfoType info<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token comment">// 查询哈希后的位置，计算 info 值</span>
    <span class="token function">keyToIdx</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token operator">&amp;</span>idx<span class="token punctuation">,</span> <span class="token operator">&amp;</span>info<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 跳过目标桶非当前位置的节点</span>
    <span class="token function">nextWhileLess</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>info<span class="token punctuation">,</span> <span class="token operator">&amp;</span>idx<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// while we potentially have a match</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>info <span class="token operator">==</span> mInfo<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 若找到相同的 key，则提前返回</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">WKeyEqual</span><span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> mKeyVals<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// key already exists, do NOT insert.</span>
        <span class="token comment">// see http://en.cppreference.com/w/cpp/container/unordered_map/insert</span>
        <span class="token keyword">return</span> std<span class="token double-colon punctuation">::</span><span class="token function">make_pair</span><span class="token punctuation">(</span>idx<span class="token punctuation">,</span> InsertionState<span class="token double-colon punctuation">::</span>key_found<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// info 一致但 key 不一致，则继续寻找下个节点</span>
      <span class="token function">next</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>info<span class="token punctuation">,</span> <span class="token operator">&amp;</span>idx<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// unlikely that this evaluates to true</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">ROBIN_HOOD_UNLIKELY</span><span class="token punctuation">(</span>mNumElements <span class="token operator">>=</span> mMaxNumElementsAllowed<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 元素数量超过允许的值后，执行 Rehash 扩容</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">increase_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> std<span class="token double-colon punctuation">::</span><span class="token function">make_pair</span><span class="token punctuation">(</span><span class="token function">size_t</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> InsertionState<span class="token double-colon punctuation">::</span>overflow_error<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">continue</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// key not found, so we are now exactly where we want to insert it.</span>
    <span class="token comment">// 当前位置 info > mInfo[idx]，准备在该位置插入</span>
    <span class="token keyword">auto</span> <span class="token keyword">const</span> insertion_idx <span class="token operator">=</span> idx<span class="token punctuation">;</span>
    <span class="token keyword">auto</span> <span class="token keyword">const</span> insertion_info <span class="token operator">=</span> info<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">ROBIN_HOOD_UNLIKELY</span><span class="token punctuation">(</span>insertion_info <span class="token operator">+</span> mInfoInc <span class="token operator">></span> <span class="token number">0xFF</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 如果 info 的值即将超过 0xFF，那么下一次插入前先执行扩容</span>
      mMaxNumElementsAllowed <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// find an empty spot</span>
    <span class="token comment">// 在插入位置继续寻找下一个空桶的位置</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">!=</span> mInfo<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">next</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>info<span class="token punctuation">,</span> <span class="token operator">&amp;</span>idx<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 如果插入位置与空桶位置不一致</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>idx <span class="token operator">!=</span> insertion_idx<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 则将插入位置到空桶前的所有元素向后移动，空出插入位置来</span>
      <span class="token function">shiftUp</span><span class="token punctuation">(</span>idx<span class="token punctuation">,</span> insertion_idx<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// put at empty spot</span>
    <span class="token comment">// 在插入位置更新 info</span>
    mInfo<span class="token punctuation">[</span>insertion_idx<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">uint8_t</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>insertion_info<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">++</span>mNumElements<span class="token punctuation">;</span>
    <span class="token comment">// 返回结果</span>
    <span class="token keyword">return</span> std<span class="token double-colon punctuation">::</span><span class="token function">make_pair</span><span class="token punctuation">(</span>
      insertion_idx<span class="token punctuation">,</span> idx <span class="token operator">==</span> insertion_idx <span class="token operator">?</span> InsertionState<span class="token double-colon punctuation">::</span>new_node
      <span class="token operator">:</span> InsertionState<span class="token double-colon punctuation">::</span>overwrite_node<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// enough attempts failed, so finally give up.</span>
  <span class="token keyword">return</span> std<span class="token double-colon punctuation">::</span><span class="token function">make_pair</span><span class="token punctuation">(</span><span class="token function">size_t</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> InsertionState<span class="token double-colon punctuation">::</span>overflow_error<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// highly performance relevant code.</span>
<span class="token comment">// Lower bits are used for indexing into the array (2^n size)</span>
<span class="token comment">// The upper 1-5 bits need to be a reasonable good hash, to save comparisons.</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">HashKey</span><span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">keyToIdx</span><span class="token punctuation">(</span>HashKey<span class="token operator">&amp;&amp;</span> key<span class="token punctuation">,</span> size_t<span class="token operator">*</span> idx<span class="token punctuation">,</span> InfoType<span class="token operator">*</span> info<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>
  <span class="token comment">// In addition to whatever hash is used, add another mul &amp; shift so we get</span>
  <span class="token comment">// better hashing. This serves as a bad hash prevention, if the given data</span>
  <span class="token comment">// is badly mixed.</span>
  <span class="token keyword">auto</span> h <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">uint64_t</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token class-name">WHash</span><span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 执行完用户提供的哈希后，再执行一次可变参数的哈希</span>
  h <span class="token operator">*=</span> mHashMultiplier<span class="token punctuation">;</span>
  h <span class="token operator">^=</span> h <span class="token operator">>></span> <span class="token number">33U</span><span class="token punctuation">;</span>

  <span class="token comment">// the lower InitialInfoNumBits are reserved for info.</span>
  <span class="token comment">// 计算 info 和插入位置 idx</span>
  <span class="token operator">*</span>info <span class="token operator">=</span> mInfoInc <span class="token operator">+</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>InfoType<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">(</span>h <span class="token operator">&amp;</span> InfoMask<span class="token punctuation">)</span> <span class="token operator">>></span> mInfoHashShift<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token operator">*</span>idx <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>size_t<span class="token operator">></span></span></span><span class="token punctuation">(</span>h<span class="token punctuation">)</span> <span class="token operator">>></span> InitialInfoNumBits<span class="token punctuation">)</span> <span class="token operator">&amp;</span> mMask<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// forwards the index by one, wrapping around at the end</span>
<span class="token keyword">void</span> <span class="token function">next</span><span class="token punctuation">(</span>InfoType<span class="token operator">*</span> info<span class="token punctuation">,</span> size_t<span class="token operator">*</span> idx<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>
  <span class="token comment">// 跳到下一个位置</span>
  <span class="token operator">*</span>idx <span class="token operator">=</span> <span class="token operator">*</span>idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token comment">// 距离需要叠加上对应的系数</span>
  <span class="token operator">*</span>info <span class="token operator">+=</span> mInfoInc<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">nextWhileLess</span><span class="token punctuation">(</span>InfoType<span class="token operator">*</span> info<span class="token punctuation">,</span> size_t<span class="token operator">*</span> idx<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>
  <span class="token comment">// unrolling this by hand did not bring any speedups.</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>info <span class="token operator">&lt;</span> mInfo<span class="token punctuation">[</span><span class="token operator">*</span>idx<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">next</span><span class="token punctuation">(</span>info<span class="token punctuation">,</span> idx<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>执行删除的代码：</p>
<pre class="language-cpp"><code class="language-cpp"><span class="token comment">// Erases element at pos, returns iterator to the next element.</span>
iterator <span class="token function">erase</span><span class="token punctuation">(</span>iterator pos<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">ROBIN_HOOD_TRACE</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
  <span class="token comment">// we assume that pos always points to a valid entry, and not end().</span>
  <span class="token keyword">auto</span> <span class="token keyword">const</span> idx <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>size_t<span class="token operator">></span></span></span><span class="token punctuation">(</span>pos<span class="token punctuation">.</span>mKeyVals <span class="token operator">-</span> mKeyVals<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">shiftDown</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token operator">--</span>mNumElements<span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>pos<span class="token punctuation">.</span>mInfo<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// we've backward shifted, return this again</span>
    <span class="token keyword">return</span> pos<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// no backward shift, return next element</span>
  <span class="token keyword">return</span> <span class="token operator">++</span>pos<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">shiftDown</span><span class="token punctuation">(</span>size_t idx<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">(</span>
  std<span class="token double-colon punctuation">::</span>is_nothrow_move_assignable<span class="token operator">&lt;</span>Node<span class="token operator">></span><span class="token double-colon punctuation">::</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// until we find one that is either empty or has zero offset.</span>
  <span class="token comment">// TODO(martinus) we don't need to move everything, just the last one for</span>
  <span class="token comment">// the same bucket.</span>
  <span class="token comment">// 析构需要删除的键值对</span>
  mKeyVals<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">destroy</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// until we find one that is either empty or has zero offset.</span>
  <span class="token comment">// 根据距离判断是否需要前移</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>mInfo<span class="token punctuation">[</span>idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">>=</span> <span class="token number">2</span> <span class="token operator">*</span> mInfoInc<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">ROBIN_HOOD_COUNT</span><span class="token punctuation">(</span>shiftDown<span class="token punctuation">)</span>
    <span class="token comment">// 距离减一</span>
    mInfo<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">uint8_t</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>mInfo<span class="token punctuation">[</span>idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> mInfoInc<span class="token punctuation">)</span><span class="token punctuation">;</span>
    mKeyVals<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>mKeyVals<span class="token punctuation">[</span>idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">++</span>idx<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  mInfo<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token comment">// don't destroy, we've moved it</span>
  <span class="token comment">// mKeyVals[idx].destroy(*this);</span>
  mKeyVals<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token operator">~</span><span class="token function">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>执行扩容的代码如下：</p>
<pre class="language-cpp"><code class="language-cpp"><span class="token comment">// True if resize was possible, false otherwise</span>
<span class="token keyword">bool</span> <span class="token function">increase_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// nothing allocated yet? just allocate InitialNumElements</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">==</span> mMask<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">initData</span><span class="token punctuation">(</span>InitialNumElements<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">auto</span> <span class="token keyword">const</span> maxNumElementsAllowed <span class="token operator">=</span> <span class="token function">calcMaxNumElementsAllowed</span><span class="token punctuation">(</span>mMask <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>mNumElements <span class="token operator">&lt;</span> maxNumElementsAllowed <span class="token operator">&amp;&amp;</span> <span class="token function">try_increase_info</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">ROBIN_HOOD_LOG</span><span class="token punctuation">(</span><span class="token string">"mNumElements="</span>
                 <span class="token operator">&lt;&lt;</span> mNumElements <span class="token operator">&lt;&lt;</span> <span class="token string">", maxNumElementsAllowed="</span>
                 <span class="token operator">&lt;&lt;</span> maxNumElementsAllowed <span class="token operator">&lt;&lt;</span> <span class="token string">", load="</span>
                 <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>mNumElements<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">100.0</span> <span class="token operator">/</span>
                     <span class="token punctuation">(</span><span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>mMask<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

  <span class="token function">nextHashMultiplier</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>mNumElements <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">&lt;</span> <span class="token function">calcMaxNumElementsAllowed</span><span class="token punctuation">(</span>mMask <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// we have to resize, even though there would still be plenty of space</span>
    <span class="token comment">// left! Try to rehash instead. Delete freed memory so we don't steadyily</span>
    <span class="token comment">// increase mem in case we have to rehash a few times</span>
    <span class="token function">rehashPowerOfTwo</span><span class="token punctuation">(</span>mMask <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// Each resize use a different hash so we don't so easily overflow.</span>
    <span class="token comment">// Make sure we only have odd numbers, so that the multiplication is</span>
    <span class="token comment">// reversible!</span>
    <span class="token function">rehashPowerOfTwo</span><span class="token punctuation">(</span><span class="token punctuation">(</span>mMask <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">nextHashMultiplier</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// adding an *even* number, so that the multiplier will always stay odd.</span>
  <span class="token comment">// This is necessary so that the hash stays a mixing function (and thus</span>
  <span class="token comment">// doesn't have any information loss).</span>
  <span class="token comment">// 修改哈希常数避免始终陷入高冲突状态</span>
  mHashMultiplier <span class="token operator">+=</span> <span class="token function">UINT64_C</span><span class="token punctuation">(</span><span class="token number">0xc4ceb9fe1a85ec54</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// reserves space for at least the specified number of elements.</span>
<span class="token comment">// only works if numBuckets if power of two</span>
<span class="token comment">// True on success, false otherwise</span>
<span class="token keyword">void</span> <span class="token function">rehashPowerOfTwo</span><span class="token punctuation">(</span>size_t numBuckets<span class="token punctuation">,</span> <span class="token keyword">bool</span> forceFree<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">ROBIN_HOOD_TRACE</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>

  Node<span class="token operator">*</span> <span class="token keyword">const</span> oldKeyVals <span class="token operator">=</span> mKeyVals<span class="token punctuation">;</span>
  <span class="token keyword">uint8_t</span> <span class="token keyword">const</span><span class="token operator">*</span> <span class="token keyword">const</span> oldInfo <span class="token operator">=</span> mInfo<span class="token punctuation">;</span>

  <span class="token keyword">const</span> size_t oldMaxElementsWithBuffer <span class="token operator">=</span>
    <span class="token function">calcNumElementsWithBuffer</span><span class="token punctuation">(</span>mMask <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// resize operation: move stuff</span>
  <span class="token function">initData</span><span class="token punctuation">(</span>numBuckets<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>oldMaxElementsWithBuffer <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> oldMaxElementsWithBuffer<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>oldInfo<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// might throw an exception, which is really bad since we are in the</span>
        <span class="token comment">// middle of moving stuff.</span>
        <span class="token function">insert_move</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>oldKeyVals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// destroy the node but DON'T destroy the data.</span>
        oldKeyVals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token operator">~</span><span class="token function">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// this check is not necessary as it's guarded by the previous if, but it</span>
    <span class="token comment">// helps silence g++'s overeager "attempt to free a non-heap object 'map'</span>
    <span class="token comment">// [-Werror=free-nonheap-object]" warning.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldKeyVals <span class="token operator">!=</span> <span class="token generic-function"><span class="token function">reinterpret_cast_no_cast_align_warning</span><span class="token generic class-name"><span class="token operator">&lt;</span>Node<span class="token operator">*</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mMask<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// don't destroy old data: put it into the pool instead</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>forceFree<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        std<span class="token double-colon punctuation">::</span><span class="token function">free</span><span class="token punctuation">(</span>oldKeyVals<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token class-name">DataPool</span><span class="token double-colon punctuation">::</span><span class="token function">addOrFree</span><span class="token punctuation">(</span>oldKeyVals<span class="token punctuation">,</span>
                            <span class="token function">calcNumBytesTotal</span><span class="token punctuation">(</span>oldMaxElementsWithBuffer<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>实际上 info 字段有限的位中还存储了部分哈希的信息用于加速找 key，随着扩容其位数会逐渐降低，这里就不再详述了。</p>
<h3 id="4.-使用建议" tabindex="-1"><a href="#4.-%E4%BD%BF%E7%94%A8%E5%BB%BA%E8%AE%AE">4. 使用建议</a></h3>
<p>并不存在某一种哈希表可以适用所有场景，不过大部分场景下 <a href="https://martin.ankerl.com/2019/04/01/hashmap-benchmarks-01-overview/">Robin Hood 的性能</a>都不错，推荐尝试。笔者之前优化的项目中哈希表占用整个服务 8% 左右的 CPU，替换为 Robin Hood 后哈希表部分的 CPU 占用降低到 3%。</p>
<h3 id="references" tabindex="-1"><a href="#references">References</a></h3>
<ol>
<li><a href="https://en.wikipedia.org/wiki/Hash_table">&quot;Hash table&quot;, <em>Wikipedia</em></a></li>
<li><a href="https://github.com/martinus/robin-hood-hashing">&quot;martinus/robin-hood-hashing&quot;, <em>GitHub</em></a></li>
</ol>

      </div>
      <script src="https://utteranc.es/client.js" repo="SF-Zhou/sf-zhou.github.io" issue-term="title" label="Comment" theme="preferred-color-scheme" crossorigin="anonymous" async> </script>
      <div class="footer">
        <div class="license">
          Except where otherwise noted, content on this site is licensed under a <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> license.
        </div>
        <div class="copyright">
          Copyright©2017 SF-Zhou, All Rights Reserved. Powered by <a href="https://pages.github.com/">GitHub Pages</a> and <a href="https://github.com/features/actions">GitHub Actions</a>.
        </div>
      </div>
    </div>
    <script src="/dist/main.js"></script>
    <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','https://www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-61723712-2', 'auto'); ga('send', 'pageview'); </script>
  </body>
</html>
