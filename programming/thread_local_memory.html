<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="shortcut icon" href="/dist/favicon.ico">
    <link rel="apple-touch-icon" href="/dist/favicon.png">
    <link rel="stylesheet" type="text/css" href="/dist/highlight.css">
    <link rel="stylesheet" type="text/css" href="/dist/katex.min.css">
    <link rel="stylesheet" type="text/css" href="/dist/main.css">
    <title>C++ TLS 触发的栈溢出 | SF-Zhou's Blog</title>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-GQ26H3JQ3G"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-GQ26H3JQ3G');
    </script>
  </head>
  <body>
    <div class="app">
      <div class="title">
        <h1> C++ TLS 触发的栈溢出 </h1>
      </div>
      <div class="info">
        <div class="date"> 2021.06.21 </div>
        <a href="https://github.com/SF-Zhou">
          <div class="author"> SF-Zhou </div>
        </a>
      </div>
      <div class="markdown">
        <p>先看一段代码，猜猜 Linux 下编译后执行会发生什么（编译参数 <code>-pthread -O2 -std=c++11</code>，<a href="https://godbolt.org/z/Pv9o8oeqs">在线执行</a>）：</p>
<pre class="language-cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread></span></span>

<span class="token keyword">thread_local</span> <span class="token keyword">char</span> tls<span class="token punctuation">[</span><span class="token number">8</span> <span class="token operator">&lt;&lt;</span> <span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">char</span> arr<span class="token punctuation">[</span><span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  arr<span class="token punctuation">[</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'A'</span><span class="token punctuation">;</span>

  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p %p\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>tls<span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span><span class="token function">thread</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
</code></pre>
<p>如果你系统的栈大小是默认的 8MB，那么上述代码会导致栈溢出。原因在于 pthread 实现中 TLS 和线程栈使用的是同一块内存空间，TLS 使用的多时留给线程栈的就少了。</p>
<p>pthread <a href="https://github.com/lattera/glibc/blob/master/nptl/nptl-init.c#L372">初始化时</a>会根据系统设定的栈大小、TLS 占用的内存空间大小计算默认的栈空间：</p>
<pre class="language-cpp"><code class="language-cpp"><span class="token comment">// 1. 获取 TLS 内存大小</span>
size_t static_tls_align<span class="token punctuation">;</span>
<span class="token function">_dl_get_tls_static_info</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>__static_tls_size<span class="token punctuation">,</span> <span class="token operator">&amp;</span>static_tls_align<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 2. 获取系统栈大小</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__getrlimit</span> <span class="token punctuation">(</span>RLIMIT_STACK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>limit<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">||</span> limit<span class="token punctuation">.</span>rlim_cur <span class="token operator">==</span> RLIM_INFINITY<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  limit<span class="token punctuation">.</span>rlim_cur <span class="token operator">=</span> ARCH_STACK_DEFAULT_SIZE<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 3. 设定 pthread 默认栈大小</span>
<span class="token keyword">const</span> size_t minstack <span class="token operator">=</span> pagesz <span class="token operator">+</span> __static_tls_size <span class="token operator">+</span> MINIMAL_REST_STACK<span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>limit<span class="token punctuation">.</span>rlim_cur <span class="token operator">&lt;</span> minstack<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  limit<span class="token punctuation">.</span>rlim_cur <span class="token operator">=</span> minstack<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
limit<span class="token punctuation">.</span>rlim_cur <span class="token operator">=</span> <span class="token function">ALIGN_UP</span> <span class="token punctuation">(</span>limit<span class="token punctuation">.</span>rlim_cur<span class="token punctuation">,</span> pagesz<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">lll_lock</span> <span class="token punctuation">(</span>__default_pthread_attr_lock<span class="token punctuation">,</span> LLL_PRIVATE<span class="token punctuation">)</span><span class="token punctuation">;</span>
__default_pthread_attr<span class="token punctuation">.</span>stacksize <span class="token operator">=</span> limit<span class="token punctuation">.</span>rlim_cur<span class="token punctuation">;</span>
__default_pthread_attr<span class="token punctuation">.</span>guardsize <span class="token operator">=</span> <span class="token function">GLRO</span> <span class="token punctuation">(</span>dl_pagesize<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">lll_unlock</span> <span class="token punctuation">(</span>__default_pthread_attr_lock<span class="token punctuation">,</span> LLL_PRIVATE<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p><code>pthread_create</code> 时如果没有指定使用的栈大小，则会使用上述计算的<a href="https://github.com/lattera/glibc/blob/master/nptl/allocatestack.c#L429">默认栈大小</a>：</p>
<pre class="language-cpp"><code class="language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span>attr<span class="token operator">-></span>stacksize <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  size <span class="token operator">=</span> attr<span class="token operator">-></span>stacksize<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  <span class="token function">lll_lock</span> <span class="token punctuation">(</span>__default_pthread_attr_lock<span class="token punctuation">,</span> LLL_PRIVATE<span class="token punctuation">)</span><span class="token punctuation">;</span>
  size <span class="token operator">=</span> __default_pthread_attr<span class="token punctuation">.</span>stacksize<span class="token punctuation">;</span>
  <span class="token function">lll_unlock</span> <span class="token punctuation">(</span>__default_pthread_attr_lock<span class="token punctuation">,</span> LLL_PRIVATE<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>如果担心 TLS 触发栈溢出，可以在程序启动时通过下方代码获取 TLS 需要使用的内存空间总大小（<a href="https://godbolt.org/z/EoEKxhhhf">在线执行</a>），可以根据该值进行阈值的判断：</p>
<pre class="language-cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>

<span class="token keyword">extern</span> <span class="token string">"C"</span> <span class="token keyword">void</span> <span class="token function">_dl_get_tls_static_info</span><span class="token punctuation">(</span>size_t <span class="token operator">*</span>sizep<span class="token punctuation">,</span> size_t <span class="token operator">*</span>alignp<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  size_t size<span class="token punctuation">;</span>
  size_t align<span class="token punctuation">;</span>
  <span class="token function">_dl_get_tls_static_info</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>size<span class="token punctuation">,</span> <span class="token operator">&amp;</span>align<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"size %lu\n"</span><span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<h3 id="rust-+-c++-联合编译新坑" tabindex="-1"><a href="#rust-%2B-c%2B%2B-%E8%81%94%E5%90%88%E7%BC%96%E8%AF%91%E6%96%B0%E5%9D%91">Rust + C++ 联合编译新坑</a></h3>
<p>没想到在 2026 年还能再次遇到这个问题。项目中混合了 Rust 和 C++，Rust 侧新增了后台线程，并且单元测试启动线程一切正常，和 C++ 联合编译后就直接炸掉。使用 LLDB attach 上去排查，能看到 fault address 是 <code>0x7f6440079fe8</code>，继续查看线程启动时栈底的地址：</p>
<pre class="language-bash"><code class="language-bash">frame <span class="token keyword">select</span> <span class="token number">23</span>
reg <span class="token builtin class-name">read</span> rsp
</code></pre>
<p>栈底的地址是 <code>0x7f644007f000</code>，整个栈的可用空间太小了。查看进程内存映射：</p>
<pre class="language-bash"><code class="language-bash"><span class="token function">cat</span> /proc/<span class="token operator">&lt;</span>PID<span class="token operator">></span>/maps <span class="token operator">|</span> <span class="token function">grep</span> 7f644007
<span class="token comment">#> 7f6440079000-7f644007a000 ---p 00000000 00:00 0</span>
<span class="token comment">#> 7f644007a000-7f64404a6000 rw-p 00000000 00:00 0</span>
</code></pre>
<p>显然线程执行之初能用的栈空间就已经没多少了。值得注意的是这段内存的大小只有 4.17MiB，并非 8MiB。简单查询后得知 Rust 默认的栈大小只有可怜的 2MiB，Rust 自身没有多少 TLS 变量，但 C++ 侧有超过 4MiB 的 TLS，所以单独跑没事，联合编译炸掉。修复方法也很简单，Rust 创建线程时将栈大小与 C++ 侧对齐即可。</p>
<h3 id="references" tabindex="-1"><a href="#references">References</a></h3>
<ol>
<li><a href="https://www.uclibc.org/docs/tls.pdf">&quot;ELF Handling For Thread-Local Storage&quot;, <em>Ulrich Drepper</em></a></li>
</ol>

      </div>
      <script src="https://giscus.app/client.js"
      data-repo="SF-Zhou/sf-zhou.github.io"
      data-repo-id="MDEwOlJlcG9zaXRvcnk4MDc5ODgwNg=="
      data-category="Announcements"
      data-category-id="DIC_kwDOBNDkVs4CA6GQ"
      data-mapping="title"
      data-reactions-enabled="0"
      data-emit-metadata="0"
      data-input-position="bottom"
      data-theme="preferred_color_scheme"
      data-lang="en"
      crossorigin="anonymous"
      async>
    </script>
      <div class="footer">
        <div class="license">
          Except where otherwise noted, content on this site is licensed under a <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> license.
        </div>
        <div class="copyright">
          Copyright©2017 SF-Zhou, All Rights Reserved. Powered by <a href="https://pages.github.com/">GitHub Pages</a> and <a href="https://github.com/features/actions">GitHub Actions</a>.
        </div>
      </div>
    </div>
    <script src="/dist/main.js"></script>
  </body>
</html>
