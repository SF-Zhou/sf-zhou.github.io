<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="shortcut icon" href="/dist/favicon.ico">
    <link rel="apple-touch-icon" href="/dist/favicon.png">
    <link rel="stylesheet" type="text/css" href="/dist/highlight.css">
    <link rel="stylesheet" type="text/css" href="/dist/katex.min.css">
    <link rel="stylesheet" type="text/css" href="/dist/gitalk.css">
    <link rel="stylesheet" type="text/css" href="/dist/main.css">
    <title>Robin Hood Hashing 源码分析 | SF-Zhou's Blog</title>
  </head>
  <body>
    <div class="app">
      <div class="title">
        <h1> Robin Hood Hashing 源码分析 </h1>
      </div>
      <div class="info">
        <div class="date"> 2021.05.21 </div>
        <a href="https://github.com/SF-Zhou">
          <div class="author"> SF-Zhou </div>
        </a>
      </div>
      <div class="markdown">
        <p>从 C++11 开始，STL 会提供哈希表 <a href="https://github.com/martinus/robin-hood-hashing"><code>std::unordered_map</code></a> 的实现，用起来确实很方便，不过性能上就差强人意了。<a href="https://github.com/martinus/robin-hood-hashing"><code>robin_hood::unordered_map</code></a> 作为 <code>std::unordered_map</code> 的替代品，提供了与标准库中一致的接口，同时带来 2 到 3 倍的性能提升，着实让人心动。笔者年前尝试使用该哈希表，但由于其<a href="https://github.com/martinus/robin-hood-hashing/issues/21">内部的 Bug</a> 导致低概率的抛出异常，不得已又退回使用标准库。今年 3 月底的时候其作者<a href="https://github.com/martinus/robin-hood-hashing/pull/121">修复了该 Bug</a>，笔者也第一时间测试使用，并上线到现网环境，截止目前无任何故障。安全起见，笔者分析了该哈希表的具体实现，分析的代码版本为 <a href="https://github.com/martinus/robin-hood-hashing/blob/3.11.1/src/include/robin_hood.h">3.11.1</a>，目前也没有发现潜在的安全隐患。依笔者之见，Robin Hood 高性能的秘诀是开放寻址、平坦化和限制冲突。</p>
<h3 id="1.-开放寻址"><a href="#1.-%E5%BC%80%E6%94%BE%E5%AF%BB%E5%9D%80">1. 开放寻址</a></h3>
<p>目前主流的 STL 实现均使用闭式寻址（Closed Addressing），当发生冲突时，需要使用额外的数据结构处理冲突。例如 GCC 中使用的是链表，查询时会先对 key 进行哈希确定桶的位置，再比对桶对应的链表中的元素。闭式寻址的优势是删除简单，相同负载系数下对比开放寻址性能更好。但冲突剧烈时，查询的复杂度也会从 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></eq> 退化到 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq>，此时也依赖 Rehash 减少冲突。</p>
<table>
<thead>
<tr>
<th>Bucket</th>
<th>Collision Chain</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td></td>
</tr>
<tr>
<td>1</td>
<td>①</td>
</tr>
<tr>
<td>2</td>
<td>②②②</td>
</tr>
<tr>
<td>3</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>④</td>
</tr>
<tr>
<td>5</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td></td>
</tr>
<tr>
<td>7</td>
<td>⑦⑦</td>
</tr>
</tbody>
</table>
<p>而 Robin Hood 中使用的是开放寻址（Open Addressing），发生冲突时会尝试找下一个空桶的位置，每个桶至多存放一个元素，这也就限制了其负载系数至多为 1。其优势是有更好的缓存局部性，负载系数低时性能优异，劣势是删除时复杂度更高，负载系数高时冲突剧烈。单纯使用开放寻址无法应对复杂的现实  需求，为了提高性能还需要额外的优化策略。</p>
<table>
<thead>
<tr>
<th>Bucket</th>
<th>Open Addressing</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>⑦</td>
</tr>
<tr>
<td>1</td>
<td>①</td>
</tr>
<tr>
<td>2</td>
<td>②</td>
</tr>
<tr>
<td>3</td>
<td>②</td>
</tr>
<tr>
<td>4</td>
<td>②</td>
</tr>
<tr>
<td>5</td>
<td>④</td>
</tr>
<tr>
<td>6</td>
<td></td>
</tr>
<tr>
<td>7</td>
<td>⑦</td>
</tr>
</tbody>
</table>
<h3 id="2.-平坦化"><a href="#2.-%E5%B9%B3%E5%9D%A6%E5%8C%96">2. 平坦化</a></h3>
<p>平坦化（Flatten）是指将哈希表中的元素直接存储在哈希桶数组中。非平坦化的实现会在哈希桶数组中存放元素的指针，查询时先读桶中的数据，再访问对应的元素，会产生一次间接寻址。平坦化则可以减少一次寻址操作，确定桶的位置后就可以直接访问元素。其优势自然是获得更好的性能和缓存局部性，劣势是需要使用更多的内存空间，以 80% 的负载系数为例，Rehash 后 60% 的内存空间存放的是空桶。另外平坦化要求键值对支持移动构造和移动复制，Robin Hood 对符合该条件并且键值对总大小小于 6 个 <code>size_t</code> 的会启用平坦化的实现：</p>
<pre class="language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">Key</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">Hash</span> <span class="token operator">=</span> hash<span class="token operator">&lt;</span>Key<span class="token operator">></span><span class="token punctuation">,</span>
          <span class="token keyword">typename</span> <span class="token class-name">KeyEqual</span> <span class="token operator">=</span> std<span class="token operator">::</span>equal_to<span class="token operator">&lt;</span>Key<span class="token operator">></span><span class="token punctuation">,</span> size_t MaxLoadFactor100 <span class="token operator">=</span> <span class="token number">80</span><span class="token operator">></span>
<span class="token keyword">using</span> unordered_map <span class="token operator">=</span> detail<span class="token operator">::</span>Table<span class="token operator">&lt;</span>
    <span class="token keyword">sizeof</span><span class="token punctuation">(</span>robin_hood<span class="token operator">::</span>pair<span class="token operator">&lt;</span>Key<span class="token punctuation">,</span> T<span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>size_t<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">6</span> <span class="token operator">&amp;&amp;</span>
        std<span class="token operator">::</span>is_nothrow_move_constructible<span class="token operator">&lt;</span>robin_hood<span class="token operator">::</span>pair<span class="token operator">&lt;</span>Key<span class="token punctuation">,</span> T<span class="token operator">>></span><span class="token operator">::</span>value <span class="token operator">&amp;&amp;</span>
        std<span class="token operator">::</span>is_nothrow_move_assignable<span class="token operator">&lt;</span>robin_hood<span class="token operator">::</span>pair<span class="token operator">&lt;</span>Key<span class="token punctuation">,</span> T<span class="token operator">>></span><span class="token operator">::</span>value<span class="token punctuation">,</span>
    MaxLoadFactor100<span class="token punctuation">,</span> Key<span class="token punctuation">,</span> T<span class="token punctuation">,</span> Hash<span class="token punctuation">,</span> KeyEqual<span class="token operator">></span><span class="token punctuation">;</span>
</code></pre>
<p>对于不符合条件的键值对，Robin Hood 中也提供了非平坦化实现。简单压测可以发现，相同的键值对类型平坦化相较于非平坦化可以提升一倍多的性能。</p>
<h3 id="3.-限制冲突"><a href="#3.-%E9%99%90%E5%88%B6%E5%86%B2%E7%AA%81">3. 限制冲突</a></h3>
<h3 id="4.-使用建议"><a href="#4.-%E4%BD%BF%E7%94%A8%E5%BB%BA%E8%AE%AE">4. 使用建议</a></h3>
<p>并不存在某一种哈希表可以适用所有场景，不过大部分场景下 <a href="https://martin.ankerl.com/2019/04/01/hashmap-benchmarks-01-overview/">Robin Hood 的性能</a>都不错，推荐尝试。笔者之前优化的项目中哈希表占用整个服务 8% 左右的 CPU，替换为 Robin Hood 后哈希表部分的 CPU 占用降低到 3%。</p>
<h3 id="references"><a href="#references">References</a></h3>
<ol>
<li><a href="https://en.wikipedia.org/wiki/Hash_table">&quot;Hash table&quot;, <em>Wikipedia</em></a></li>
</ol>

      </div>
      <div id="gitalk-container">
      </div>
      <div class="footer">
        <div class="license">
          Except where otherwise noted, content on this site is licensed under a <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> license.
        </div>
        <div class="copyright">
          Copyright©2021 SF-Zhou, All Rights Reserved. Powered by <a href="https://pages.github.com/">GitHub Pages</a> and <a href="https://github.com/features/actions">GitHub Actions</a>.
        </div>
      </div>
    </div>
    <script src="/dist/gitalk.min.js"></script>
    <script src="/dist/main.js"></script>
    <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','https://www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-61723712-2', 'auto'); ga('send', 'pageview'); </script>
  </body>
</html>
