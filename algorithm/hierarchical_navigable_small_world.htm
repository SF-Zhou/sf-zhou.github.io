<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="shortcut icon" href="/dist/favicon.ico">
    <link rel="apple-touch-icon" href="/dist/favicon.png">
    <link rel="stylesheet" type="text/css" href="/dist/highlight.css">
    <link rel="stylesheet" type="text/css" href="/dist/katex.min.css">
    <link rel="stylesheet" type="text/css" href="/dist/gitalk.css">
    <link rel="stylesheet" type="text/css" href="/dist/main.css">
    <title>[Reading] Hierarchical Navigable Small World graphs | SF-Zhou's Blog</title>
  </head>
  <body>
    <div class="app">
      <div class="title">
        <h1> [Reading] Hierarchical Navigable Small World graphs </h1>
      </div>
      <div class="info">
        <div class="date"> 2019.02.13 </div>
        <a href="https://github.com/SF-Zhou">
          <div class="author"> SF-Zhou </div>
        </a>
      </div>
      <div class="markdown">
        <h3 id="abstract"><a href="#abstract">Abstract</a></h3>
<blockquote>
<p>We present a new approach for the approximate K-nearest neighbor search based on navigable small world graphs with controllable hierarchy (Hierarchical NSW, HNSW). The proposed solution is fully graph-based, without any need for additional search structures, which are typically used at the coarse search stage of the most proximity graph techniques. Hierarchical NSW incrementally builds a multi-layer structure consisting from hierarchical set of proximity graphs (layers) for nested subsets of the stored elements. The maximum layer in which an element is present is selected randomly with an exponentially decaying probability distribution. This allows producing graphs similar to the previously studied Navigable Small World (NSW) structures while additionally having the links separated by their characteristic distance scales. Starting search from the upper layer together with utilizing the scale separation boosts the performance compared to NSW and allows a logarithmic complexity scaling. Additional employment of a heuristic for selecting proximity graph neighbors significantly increases performance at high recall and in case of highly clustered data. Performance evaluation has demonstrated that the proposed general metric space search index is able to strongly outperform previous opensource state-of-the-art vector-only approaches. Similarity of the algorithm to the skip list structure allows straightforward balanced distributed implementation.</p>
</blockquote>
<h3 id="motivation"><a href="#motivation">Motivation</a></h3>
<p>The ways of improving the NSW search complexity can be identified through the analysis of the routing process.  The routing can be divided into two phases: &quot;zoom-out&quot; and &quot;zoom-in&quot;. The average degree of a node can stay relatively small, which leads to an increased probability of being stuck in a distant false local minimum. One can avoid the described problem in NSW by starting the search from a node with the maximum degree, directly going to the &quot;zoom-in&quot; phase of the search. However, it still has only a polylogarithmic complexity scalability of a single greedy search at best.</p>
<p>The average number of hops scales logarithmically, while the average degree of the nodes on the greedy path also scales logarithmically. Thus we get an overall polylogarithmic dependence of the resulting complexity.</p>
<p>The idea of <strong>Hierarchical NSW</strong> algorithm is to separate the links according to their length scale into different layers and then search in a multilayer graph. The algorithm greedily traverses through the elements from the upper layer until a local minimum is reached. After that, the search switches to the lower layer (which has shorter links), restarts from the element which was the local minimum in the previous layer and the process repeats. The maximum number of connections per element in all layers can be made constant, thus allowing a logarithmic complexity scaling of routing in a navigable small world network.</p>
<figure tabindex="1"><a href="../images/bb11d53a73d61777b0939e5cc23249c2.svg"><img src="../images/bb11d53a73d61777b0939e5cc23249c2.svg" alt=""></a></figure>
<p>One way to form such a layered structure is to explicitly set links with different length scales by introducing layers. For every element we select an integer level <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span></eq> which defines the maximum layer for which the element belongs to. If we set an exponentially decaying probability of <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span></eq>, we get a logarithmic scaling of the expected number of layers in the structure.</p>
<h3 id="algorithm"><a href="#algorithm">Algorithm</a></h3>
<figure tabindex="2"><a href="../images/c936fb5cd172bca150de65a4f8dbd8a2.svg"><img src="../images/c936fb5cd172bca150de65a4f8dbd8a2.svg" alt=""></a></figure>
<figure tabindex="3"><a href="../images/64a8c51b9836a8f0ebb55d5c1a7bc51e.svg"><img src="../images/64a8c51b9836a8f0ebb55d5c1a7bc51e.svg" alt=""></a></figure>
<figure tabindex="4"><a href="../images/89e31183a895d3c2b00eb4fa7a90d71a.svg"><img src="../images/89e31183a895d3c2b00eb4fa7a90d71a.svg" alt=""></a></figure>
<figure tabindex="5"><a href="../images/ec851204331145d283bd5dd1619b75d4.svg"><img src="../images/ec851204331145d283bd5dd1619b75d4.svg" alt=""></a></figure>
<figure tabindex="6"><a href="../images/1da118e50a12d90d12c2c062676ae7c7.svg"><img src="../images/1da118e50a12d90d12c2c062676ae7c7.svg" alt=""></a></figure>
<h3 id="references"><a href="#references">References</a></h3>
<ol>
<li><a href="https://arxiv.org/pdf/1603.09320.pdf">Malkov, Yury A., and Dmitry A. Yashunin. &quot;Efficient and robust approximate nearest neighbor search using Hierarchical Navigable Small World graphs.&quot; <em>IEEE transactions on pattern analysis and machine intelligence</em> (2018).</a></li>
<li><a href="https://github.com/nmslib/hnswlib">GitHub nmslib/hnswlib</a>.</li>
</ol>

      </div>
      <div id="gitalk-container">
      </div>
      <div class="footer">
        <div class="license">
          Except where otherwise noted, content on this site is licensed under a <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> license.
        </div>
        <div class="copyright">
          CopyrightÂ©2020 SF-Zhou, All Rights Reserved. Powered by <a href="https://pages.github.com/">GitHub Pages</a> and <a href="https://travis-ci.com/SF-Zhou/sf-zhou.github.io">Travis CI</a>.
        </div>
      </div>
    </div>
    <script src="/dist/gitalk.min.js"></script>
    <script src="/dist/main.js"></script>
  </body>
</html>
