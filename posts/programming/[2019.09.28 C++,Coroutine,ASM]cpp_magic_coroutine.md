# 汇编魔法实现 C++ 协程

协程，简而言之就是用户态线程。C++ 官方协程已经被提上日程，乐观估计 2020 年能发布，然后 2025 年能用上。但当下的性能问题亟待解决，没有官方实现也可以自己造轮子。除了切换到 Go、使用语言级支持的协程外，也可以在 C++ 内使用基于汇编实现的协程，比如微信开源的 [libco](https://github.com/Tencent/libco)。本文将从简单的汇编开始，逐步分析 x86-64 环境下协程的实现原理。

###1. 栈帧 Stack Frames

在 C++ 的执行环境下，通常会在调用函数时为其分配栈帧使其有独立的内存空间放置临时变量。一般使用 `RBP` 寄存器（x86 则是 `EBP` 寄存器）存储栈帧的底部位置，然后使用 `RBP` 寄存器和偏移量定位临时变量。举个例子：

```c++
void func() {
  int a, b, c;
  ...
  return;
}

int main() {
  func();
}
```

对应的汇编可能是这样的：

```assembly
_Z4funcv:
  push rbp     ; 存储 RBP 的值
  mov rbp, rsp ; 将 RPB 指向当前栈顶 RSP
  sub rsp, 12  ; 将栈顶上移 12 个字节，为临时变量 a/b/c 腾出空间
               ; a = [rbp - 4], b = [rbp - 8], c = [rbp - 12]
  mov rsp, rbp ; 恢复栈顶指针 RSP
  pop rbp      ; 恢复 RBP 的值，即为函数调用者的栈帧地址
  ret          ; 读取栈顶存储的返回地址，弹出，返回

main:
  push rbp
  mov rbp, rsp
  call _Z4funcv
  mov eax, 0
  pop rbp
  ret
```

其中 `call` 会将函数的返回地址压栈，并 `jump` 到函数的起始位置，相当于：

```assembly
push rip + 2 ; 返回地址为当前地址加两条指令的偏移量
jmp _Z4funcv
```

对于有参数的函数，编译器会根据参数的数量和大小，使用寄存器或栈进行传递，例如：

```c++
int add(int x, int y) {
  return x + y;
}

struct Array {
  int values[8];
};

int sum(Array arr) {
  return arr.values[0] + arr.values[1];
}
```

对应的汇编：

```assembly
_Z3addii:
  push rbp
  mov rbp, rsp
  mov DWORD PTR [rbp-4], edi ; 参数较少时使用 rdi 和 rsi 等寄存器传递，这里取其低 32 位
  mov DWORD PTR [rbp-8], esi ; 如果使用 -O2 优化，会消除这几句冗余的传值
  mov edx, DWORD PTR [rbp-4]
  mov eax, DWORD PTR [rbp-8]
  add eax, edx
  pop rbp
  ret

_Z3sum5Array:
  push rbp
  mov rbp, rsp
  mov edx, DWORD PTR [rbp+16] ; 参数较大/多时使用栈传递，此时 [rbp] 存储调用者 rbp 寄存器值
  mov eax, DWORD PTR [rbp+20] ; [rbp+8] 存储返回地址
  add eax, edx
  pop rbp
  ret
```

由于依靠 `RBP` 定位临时变量的位置，一般称其为 Frame Pointer，称 `RSP` 为 Stack Pointer。一般会要求 `RSP` 始终指向栈顶的位置，以保证可以在中断的情况下根据 `RSP` 申请新的栈帧处理中断任务。注意栈一般是朝着内存地址减小的方向增长的。栈帧示意图：

```
|low  addr|
|---------|
|   ...   | <- [rsp] 栈顶
|   ...   |
|   ...   | <- [rbp - x] 函数临时变量
|---------|
|   RBP'  | <- [rbp + 0] 调用者原 RBP 值
|---------|
| RetAddr | <- [rbp + 8] 返回地址
|---------|
|   ...   | <- [rbp + x] 函数参数
|---------|
|high addr|
```

了解了栈帧之后，就可以尝试使用汇编实现一些魔法了，比如：

```c++
#include <iostream>

extern "C" void run(void *) asm("run");
asm(R"(
run:
  jmp *%rdi
)");

void func() {
  std::cout << "Hello ASM" << std::endl;
}

int main() {
  run((void *)func);
}
```

上述代码需要 C++11 支持，[可以点击此处在线编译执行](https://godbolt.org/z/ZHvSM8)。这里手写了一个汇编函数 `run`，其功能为跳转到第一个参数指向的地址处，即 `func` 函数。由于返回地址仍然是 `main` 函数的位置，故不需要其他额外的修改操作。

而这就是实现协程切换的核心魔法了。

### 2. 协程切换 Swap Coroutines

「持续写作中……预计 28 日完成」

### References

1. ["Coroutines (C++20)", *C++ References*](https://en.cppreference.com/w/cpp/language/coroutines)
2. ["libco", *GitHub/Tencent*](https://github.com/Tencent/libco)
3. ["libco 分析(上)：协程的实现", *Kaiyuan Blog*](http://kaiyuan.me/2017/07/10/libco/)
4. ["Functions and Stack Frames", *x86 Disassembly*](https://en.m.wikibooks.org/wiki/X86_Disassembly/Functions_and_Stack_Frames)
5. ["FPO", *Larry Osterman's WebLog*](https://blogs.msdn.microsoft.com/larryosterman/2007/03/12/fpo/)
6. [*Compiler Explorer*](https://godbolt.org/)

