# C++ 静态反射与序列化

最近使用 FlatBuffers 作为 RPC 的序列化协议时，遇到一些问题：

1. FlatBuffers 支持的数据类型是有限的，特定的数据类型需要在序列化/反序列化时手动进行转换；
2. FlatBuffers 代码生成的 TableType 并不易用，手动调用 Builder 进行构造容易出错；
3. FlatBuffers 代码生成的 NativeType 性能堪忧，使用该类型也会丧失无需反序列化的优势。

仔细思考了下，当前的项目并不需要支持跨语言的 RPC 调用，只需要处理 C++ 中的序列化/反序列化；易用性反而是需求的重点，各类自定义的数据结构都希望可以方便的进行序列化/反序列化而不需要手动的进行转换。在参考了部分开源项目的思路后，决定抛弃 FlatBuffers、使用 C++ 原生数据结构 + 宏的方式定义类型 Schema、完成序列化/反序列化。

### 1. 静态反射

静态反射的实现参考 [garbageslam/visit_struct](https://github.com/garbageslam/visit_struct#intrusive-syntax) 项目中侵入式定义，它的核心原理是函数的可见范围，及派生类向基类的自动类型转换。举个例子（[在线执行](https://godbolt.org/z/sYdPd3P4e)）：

```cpp
#include <iostream>
#include <string_view>
#include <tuple>
#include <variant>
#include <algorithm>

using namespace std::string_view_literals;

template <class... Ts>
struct TypeList {
  static constexpr const unsigned int size = sizeof...(Ts);
};

template <class List, class T>
struct Append;

template <class... Ts, class T>
struct Append<TypeList<Ts...>, T> {
  using type = TypeList<Ts..., T>;
};

template <int N>
struct Rank : Rank<N - 1> {};

template <>
struct Rank<0> {};

constexpr auto kMaxRank = 100;

template <class T>
struct Base {
  using Self = T;
  static inline TypeList<> CollectField(Rank<0>);
};

template <size_t N>
struct NameWrapper {
  constexpr NameWrapper(const char(&str)[N]) { std::copy_n(str, N, string); }
  constexpr operator std::string_view() const { return {string, N - 1}; }
  char string[N];
};

template <NameWrapper Name, auto Getter, auto Checker>
struct TypeHelper {
  static constexpr std::string_view name = Name;
  static constexpr auto getter = Getter;
  static constexpr auto checker = Checker;
};

struct Helper {
  template <class T>
  using List = decltype(T::CollectField(Rank<kMaxRank>{}));

  template <class T>
  static inline constexpr auto Size = List<T>::size;

  template <class T>
  struct Extract;

  template <class T, class... Ts>
  struct Extract<TypeList<T, Ts...>> {
    using type = T;
    using remain = TypeList<Ts...>;
  };

  template <class F, class T, class L = List<T>>
  static inline void Iterate(F &&f, T &a) {
    f(Extract<L>::type::name, a.*Extract<L>::type::getter);
    if
      constexpr(Extract<L>::remain::size > 0) {
        Iterate<F, T, typename Extract<L>::remain>(std::forward<F>(f), a);
      }
  }
};

#define ADD_FIELD(T, name, defaultValue, checker)                    \
 private:                                                            \
  friend struct Helper;                                              \
  T name##_{defaultValue};                                           \
                                                                     \
 public:                                                             \
  const T &name() const { return name##_; }                          \
  T &name() { return name##_; }                                      \
                                                                     \
 private:                                                            \
  static inline Append<                                              \
      decltype(CollectField(Rank<kMaxRank>{})),                      \
      TypeHelper<NameWrapper(#name), &Self::name##_, checker>>::type \
  CollectField(Rank<decltype(CollectField(Rank<kMaxRank>{}))::size + 1>)

struct A : public Base<A> {
  int ok;

  ADD_FIELD(int, a, 110, nullptr);
  ADD_FIELD(double, b, 1.2, nullptr);
  ADD_FIELD(std::string, c, "OK", nullptr);
  ADD_FIELD(uint32_t, d, 27, nullptr);

  std::string others;
};

int main() {
  std::cout << Helper::Size<A> << std::endl;

  A a;
  Helper::Iterate([](std::string_view name, auto &&value) {
    std::cout << "name: " << name << ", ";
    std::cout << "value: " << value << std::endl;
  }, a);

  return 0;
}

/*
 * 4
 * name: a, value: 110
 * name: b, value: 1.2
 * name: c, value: OK
 * name: d, value: 27
 */
```

### 2. 序列化

有了静态反射，序列化就变成了一项体力活了。这里参考了 [eyalz800/zpp_bits](https://github.com/eyalz800/zpp_bits) 项目中的二进制序列化方式，同时使用 [marzer/tomlplusplus](https://github.com/marzer/tomlplusplus) 也实现了一套序列化到 TOML 类型的逻辑。

### References

1. [garbageslam/visit_struct](https://github.com/garbageslam/visit_struct)
2. [eyalz800/zpp_bits](https://github.com/eyalz800/zpp_bits)
3. [marzer/tomlplusplus](https://github.com/marzer/tomlplusplus)
