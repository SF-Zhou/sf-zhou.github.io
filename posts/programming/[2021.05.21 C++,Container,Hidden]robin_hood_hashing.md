# Robin Hood Hashing 源码分析

从 C++11 开始，STL 会提供哈希表 [`std::unordered_map`](https://github.com/martinus/robin-hood-hashing) 的实现，用起来确实很方便，不过性能上就差强人意了。[`robin_hood::unordered_map`](https://github.com/martinus/robin-hood-hashing) 作为 `std::unordered_map` 的替代品，提供了与标准库中一致的接口，同时带来 2 到 3 倍的性能提升，着实让人心动。笔者年前尝试使用该哈希表，但由于其[内部的 Bug](https://github.com/martinus/robin-hood-hashing/issues/21) 导致低概率的抛出异常，不得已又退回使用标准库。今年 3 月底的时候其作者[修复了该 Bug](https://github.com/martinus/robin-hood-hashing/pull/121)，笔者也第一时间测试使用，并上线到现网环境，截止目前无任何故障。安全起见，笔者分析了该哈希表的具体实现，分析的代码版本为 [3.11.1](https://github.com/martinus/robin-hood-hashing/blob/3.11.1/src/include/robin_hood.h)，目前也没有发现潜在的安全隐患。依笔者之见，Robin Hood 高性能的秘诀是开放寻址、平坦化和限制冲突。

### 1. 开放寻址

目前主流的 STL 实现均使用闭式寻址（Closed Addressing），当发生冲突时，需要使用额外的数据结构处理冲突。例如 GCC 中使用的是链表，查询时会先对 key 进行哈希确定桶的位置，再比对桶对应的链表中的元素。闭式寻址的优势是删除简单，相同负载系数下对比开放寻址性能更好。但冲突剧烈时，查询的复杂度也会从 $\mathcal O(1)$ 退化到 $\mathcal O(n)$，此时也依赖 Rehash 减少冲突。

| Bucket | Collision Chain |
| ------ | --------------- |
| 0      |                 |
| 1      | ①               |
| 2      | ②②②             |
| 3      |                 |
| 4      | ④               |
| 5      |                 |
| 6      |                 |
| 7      | ⑦⑦              |

而 Robin Hood 中使用的是开放寻址（Open Addressing），发生冲突时会尝试找下一个空桶的位置，每个桶至多存放一个元素，这也就限制了其负载系数至多为 1。其优势是有更好的缓存局部性，负载系数低时性能优异，劣势是删除时复杂度更高，负载系数高时冲突剧烈。单纯使用开放寻址无法应对复杂的现实  需求，为了提高性能还需要额外的优化策略。

| Bucket | Open Addressing |
| ------ | --------------- |
| 0      | ⑦               |
| 1      | ①               |
| 2      | ②               |
| 3      | ②               |
| 4      | ②               |
| 5      | ④               |
| 6      |                 |
| 7      | ⑦               |

### 2. 平坦化

平坦化（Flatten）是指将哈希表中的元素直接存储在哈希桶数组中。非平坦化的实现会在哈希桶数组中存放元素的指针，查询时先读桶中的数据，再访问对应的元素，会产生一次间接寻址。平坦化则可以减少一次寻址操作，确定桶的位置后就可以直接访问元素。其优势自然是获得更好的性能和缓存局部性，劣势是需要使用更多的内存空间，以 80% 的负载系数为例，Rehash 后 60% 的内存空间存放的是空桶。另外平坦化要求键值对支持移动构造和移动复制，Robin Hood 对符合该条件并且键值对总大小小于 6 个 `size_t` 的会启用平坦化的实现：

```c++
template <typename Key, typename T, typename Hash = hash<Key>,
          typename KeyEqual = std::equal_to<Key>, size_t MaxLoadFactor100 = 80>
using unordered_map = detail::Table<
    sizeof(robin_hood::pair<Key, T>) <= sizeof(size_t) * 6 &&
        std::is_nothrow_move_constructible<robin_hood::pair<Key, T>>::value &&
        std::is_nothrow_move_assignable<robin_hood::pair<Key, T>>::value,
    MaxLoadFactor100, Key, T, Hash, KeyEqual>;
```

对于不符合条件的键值对，Robin Hood 中也提供了非平坦化实现。简单压测可以发现，相同的键值对类型平坦化相较于非平坦化可以提升一倍多的性能。 

### 3. 限制冲突



### 4. 使用建议

并不存在某一种哈希表可以适用所有场景，不过大部分场景下 [Robin Hood 的性能](https://martin.ankerl.com/2019/04/01/hashmap-benchmarks-01-overview/)都不错，推荐尝试。笔者之前优化的项目中哈希表占用整个服务 8% 左右的 CPU，替换为 Robin Hood 后哈希表部分的 CPU 占用降低到 3%。

### References

1. ["Hash table", *Wikipedia*](https://en.wikipedia.org/wiki/Hash_table)

