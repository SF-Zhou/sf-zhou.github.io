# 从零开始构建 Rust RPC 框架「二、渐入佳境」

### 1. 重构

上一篇博文中，阐述了如何打造一个最简化的 RPC 框架，但这离设想的星辰大海还很远。所以我对目前的代码进行了重构，使其基础结构能够支撑未来的开发需求。

回顾一下重点目标，基于这些目标需要完成如下的工作：

1. 传输协议支持 TCP、WebSocket 和 RDMA，那么：
   1. 要抽象出一层连接 Socket 和连接管理器 SocketPool，以支持不同的连接类型；
   2. 为了高性能地处理不同连接类型异步函数的动态派发，决定使用 `enum` 手动处理派发。
2. 支持反向 RPC，server 可以调用 client 提供的方法，那么：
   1. 连接本身要支持全双工，server 端可以通过请求所在的连接发送对应的回包或者另一个新请求；
   2. client 端也可以注册方法，目前来看只能在 context 中管理注册方法的 router 了。
3. 支持反射，server 能否向 client 暴露和描述自身所提供的服务和方法，那么：
   1. context 中可以获取到所有的方法及其类型定义，包含 router 的话可以解决该问题；
   2. 所有的请求参数和返回值均要求使用 [schemars](https://crates.io/crates/schemars) 修饰，暴露 JSON Schema。

基于上述的想法，进一步地明确 `Context` 的定义。客户端请求传入的 context 与服务端处理请求接收到的 context 的类型是完全一致的，我们既希望在获取到 context 的时候有能力处理请求、发起新请求，又希望在客户端可以支持注册方法，那么 context 实际上就需要包含了以下几部分：

首先是明确 `Context` 的定义。RuaPC 为了追求对称，客户端请求传入的 context 与服务端处理请求接收到的 context 的类型是完全一致的，并且希望在获取到 context 的时候有能力发起请求，那么 context 实际上就需要包含了以下几部分：

1. 连接管理器，client/server 发送请求时需要从 context 里获取连接；
2. 方法路由，管理所有注册的服务和方法，并且有反射的能力；
3. 请求自身相关信息，包括请求来源的 socket、附带的 meta 信息。

这些部分可以进一步地抽象为两部分：全局状态 `State` 和请求元信息 `ReqMeta`。

### 2. 全双工通信

为了提高通信性能以及实现反向 RPC，需要在 TCP 上实现收发消息的全双工通信，做到发送与接收互不干扰。实现的策略也很简单，客户端在每一条请求中增加一个全局唯一的 msg id，服务端回包中附带请求的 msg id，客户端收到一致的 msg id 后唤醒对应的请求。