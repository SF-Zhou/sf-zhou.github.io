# åˆæ¢ C++20 åç¨‹

å»å¹´å­¦ä¹  `libco` æ—¶å†™è¿‡ä¸€ç¯‡åšæ–‡ï¼Œ[è®²è¿°å¦‚ä½•ä½¿ç”¨æ±‡ç¼–å®ç°åç¨‹åˆ‡æ¢](/programming/cpp_magic_coroutine.html)ã€‚ä»Šå¹´å®˜æ–¹çš„åç¨‹å®ç°æ›´åŠ æˆç†Ÿï¼Œç¼–è¯‘å™¨åŸç”Ÿæ”¯æŒåŠ ä¸Šæ— æ ˆçš„è®¾è®¡éƒ½å¸å¼•ç€ç¬”è€…ï¼Œå³ä½¿å·¥ä½œä¸­æ²¡æ³•ç”¨ä¸Šä¹Ÿæƒ³ä¸€æ¢ç©¶ç«Ÿã€‚æœ€è¿‘ Mac ä¸Šå¯ä»¥ç›´æ¥é€šè¿‡ Homebrew å®‰è£… gcc 10.1 äº†ï¼Œå€Ÿæ­¤æœºä¼šæ¢ç´¢ä¸€ä¸‹ C++20 åç¨‹çš„ç©æ³•ã€‚

é¦–å…ˆå»ºè®®é˜…è¯»[å‚è€ƒæ–‡çŒ® 1](https://en.cppreference.com/w/cpp/language/coroutines)ï¼Œå¯ä»¥æ­é…æœ¬æ–‡ä¸­çš„å‡ ä¸ªä¾‹å­åŒæ­¥å­¦ä¹ ã€‚é¦–å…ˆçœ‹è¿™ä¸ªä¾‹å­ğŸŒ°ï¼ˆ[åœ¨çº¿æ‰§è¡Œ](https://godbolt.org/z/aGEo3j)ï¼‰ï¼š

```c++
#include <coroutine>
#include <iostream>

struct Awaiter {
  bool await_ready() {
    std::cout << "await ready or not" << std::endl;
    return true;
  }

  void await_resume() {
    std::cout << "await resumed" << std::endl;
  }

  void await_suspend(std::coroutine_handle<> h) {
    std::cout << "await suspended" << std::endl;
  }
};

struct Promise {
  struct promise_type {
    auto get_return_object() noexcept {
      std::cout << "get return object" << std::endl;
      return Promise();
    }

    auto initial_suspend() noexcept {
      std::cout << "initial suspend, return never" << std::endl;
      return std::suspend_never{};
    }

    auto final_suspend() noexcept {
      std::cout << "final suspend, return never" << std::endl;
      return std::suspend_never{};
    }

    void unhandled_exception() {
      std::cout << "unhandle exception" << std::endl;
      std::terminate();
    }

    void return_void() {
      std::cout << "return void" << std::endl;
      return;
    }
  };
};

Promise CoroutineFunc() {
  std::cout << "before co_await" << std::endl;
  co_await Awaiter();
  std::cout << "after co_await" << std::endl;
}

int main() {
  std::cout << "main() start" << std::endl;
  CoroutineFunc();
  std::cout << "main() exit" << std::endl;
}

/*
main() start
get return object
initial suspend, return never
before co_await
await ready or not
await resumed
after co_await
return void
final suspend, return never
main() exit
*/
```

å½“å‡½æ•°ä¸­ä½¿ç”¨ `co_await` / `co_yield` / `co_return` å…³é”®å­—æ—¶ï¼Œç¼–è¯‘å™¨ä¼šå°†è¯¥å‡½æ•°è¯†åˆ«ä¸ºåç¨‹ã€‚æ¯ä¸ªåç¨‹å‡½æ•°éƒ½éœ€è¦ä½¿ç”¨åç¨‹çŠ¶æ€ `coroutine state` æ¥å­˜å‚¨å†…éƒ¨æ•°æ®ï¼ŒåŒ…æ‹¬åç¨‹æ‰¿è¯º `promise`ã€ä¼ å…¥åç¨‹çš„å‚æ•°ã€å½“å‰æŒ‚èµ·ç‚¹çš„æŸç§è¡¨ç¤ºå½¢å¼ä»¥åŠå½“å‰æŒ‚èµ·ç‚¹èŒƒå›´å†…çš„å±€éƒ¨å˜é‡å’Œä¸´æ—¶å˜é‡ã€‚è¯¥çŠ¶æ€åˆ†é…åœ¨å †ä¸Šï¼Œç”±ç¼–è¯‘å™¨è´Ÿè´£ç®¡ç†ã€‚åç¨‹æ‰¿è¯º `promise` ç”±åç¨‹å†…éƒ¨æ§åˆ¶ï¼Œç”¨äºåç¨‹æäº¤ç»“æœæˆ–å¼‚å¸¸ï¼›åç¨‹å¥æŸ„ `coroutine handle` ç”±åç¨‹å¤–éƒ¨æ§åˆ¶ï¼Œç”¨äºæ¢å¤åç¨‹æ‰§è¡Œæˆ–é”€æ¯åç¨‹ã€‚

å½“è°ƒç”¨åç¨‹å‡½æ•°æ—¶ï¼Œå…¶æ­¥éª¤å¦‚ä¸‹ï¼š

1. ä½¿ç”¨ `operator new` ç”³è¯·ç©ºé—´å¹¶åˆå§‹åŒ–åç¨‹çŠ¶æ€ï¼›
2. å¤åˆ¶åç¨‹å‚æ•°åˆ°åˆ°åç¨‹çŠ¶æ€ä¸­ï¼›
3. æ„é€ åç¨‹æ‰¿è¯ºå¯¹è±¡ `promise`ï¼›
4. è°ƒç”¨ `promise.get_return_object()` å¹¶å°†å…¶ç»“æœå­˜å‚¨åœ¨å±€éƒ¨å˜é‡ä¸­ã€‚è¯¥ç»“æœå°†ä¼šåœ¨åç¨‹é¦–æ¬¡æŒ‚èµ·æ—¶è¿”å›ç»™è°ƒç”¨è€…ï¼›
5. è°ƒç”¨ `co_await promise.initial_suspend()`ï¼Œé¢„å®šä¹‰äº† `std::suspend_always` è¡¨ç¤ºå§‹ç»ˆæŒ‚èµ·ï¼Œ`std::suspend_never` è¡¨ç¤ºå§‹ç»ˆä¸æŒ‚èµ·ï¼›
6. è€Œåæ­£å¼å¼€å§‹æ‰§è¡Œåç¨‹å‡½æ•°å†…è¿‡ç¨‹ã€‚

å½“åç¨‹å‡½æ•°æ‰§è¡Œåˆ° `co_await` è¡¨ç¤ºçš„æŒ‚èµ·ç‚¹æ—¶ï¼š

1. `co_await` çš„è¿”å›å€¼ä¼šè¿”å›ç»™åç¨‹è°ƒç”¨è€…/æ¢å¤è€…ã€‚

å½“åç¨‹å› ä¸ºæŸä¸ªæœªæ•è·çš„å¼‚å¸¸å¯¼è‡´ç»ˆæ­¢æ—¶ï¼š

1. æ•è·å¼‚å¸¸å¹¶è°ƒç”¨ `promise.unhandled_exception()`ï¼›
2. è°ƒç”¨ `co_await promise.final_suspend()`ã€‚

å½“åç¨‹çŠ¶æ€é”€æ¯æ—¶ï¼ˆé€šè¿‡åç¨‹å¥æŸ„ä¸»åŠ¨é”€æ¯ / `co_return` è¿”å› / æœªæ•è·å¼‚å¸¸ï¼‰ï¼š

1. ææ„ `promise` å¯¹è±¡ï¼›
2. ææ„ä¼ å…¥çš„å‚æ•°ï¼›
3. å›æ”¶åç¨‹çŠ¶æ€å†…å­˜ã€‚

æ¥ç€æ¥çœ‹æ–°çš„å…³é”®å­— `co_await`ã€‚`co_await` ä¼šå°†åç¨‹æŒ‚èµ·å¹¶å°†æ§åˆ¶æƒè¿”å›ç»™è°ƒç”¨è€…ã€‚`co_await expr`  æ‰§è¡Œæ—¶ `expr` å¯èƒ½ä¼šæœ‰ä¸€äº›è½¬æ¢ï¼Œè¿™é‡Œå°†å…¶ç®€åŒ–ä¸ºä¸€ä¸ª `awaiter` å¯¹è±¡ã€‚é¦–å…ˆä¼šæ‰§è¡Œ `awaiter.await_ready()` åˆ¤æ–­æ˜¯å¦éœ€è¦æŒ‚èµ·åç¨‹ï¼Œè¿”å› `true` åˆ™è¡¨ç¤ºæ— é¡»æŒ‚èµ·ï¼Œä¼šç´§æ¥ç€æ‰§è¡Œ `awaiter.await_resume()` å¹¶æ¢å¤åç¨‹å‡½æ•°æ‰§è¡Œã€‚ä¸Šé¢çš„ä¾‹å­ä¸­å°±æ˜¯è¿™ç§æƒ…å†µï¼Œåç¨‹ä¼šç»§ç»­åŒæ­¥æ‰§è¡Œç›´åˆ°ç»“æŸã€‚

åä¹‹ï¼Œå¦‚æœè¿”å› `false`ï¼Œåˆ™ä¼šè§¦å‘ `awaiter.await_suspend(handle)`ï¼Œå¹¶ç›´åˆ° `handle.resume()` æ‰§è¡Œåè¯¥åç¨‹æ‰ä¼šæ¢å¤æ‰§è¡Œã€‚çœ‹å¦ä¸€ä¸ªä¾‹å­ğŸŒ°ï¼ˆ[åœ¨çº¿æ‰§è¡Œ](https://godbolt.org/z/soG5P1)ï¼‰ï¼š

```c++
#include <coroutine>
#include <iostream>
#include <thread>

std::coroutine_handle<> handle;

struct Awaiter {
  bool await_ready() {
    std::cout << "await ready or not" << std::endl;
    return false;
  }

  void await_resume() {
    std::cout << "await resumed" << std::endl;
  }

  void await_suspend(std::coroutine_handle<> h) {
    std::cout << "await suspended" << std::endl;
    handle = h;
  }
};

struct Promise {
  struct promise_type {
    auto get_return_object() noexcept {
      std::cout << "get return object" << std::endl;
      return Promise();
    }

    auto initial_suspend() noexcept {
      std::cout << "initial suspend, return never" << std::endl;
      return std::suspend_never{};
    }

    auto final_suspend() noexcept {
      std::cout << "final suspend, return never" << std::endl;
      return std::suspend_never{};
    }

    void unhandled_exception() {
      std::cout << "unhandle exception" << std::endl;
      std::terminate();
    }

    void return_void() {
      std::cout << "return void" << std::endl;
      return;
    }
  };
};

Promise CoroutineFunc() {
  std::cout << "before co_await" << std::endl;
  co_await Awaiter();
  std::cout << "after co_await" << std::endl;
}

int main() {
  std::cout << "main() start" << std::endl;
  CoroutineFunc();

  std::this_thread::sleep_for(std::chrono::seconds(1));
  std::cout << "resume coroutine after one second" << std::endl;
  handle.resume();

  std::cout << "main() exit" << std::endl;
}
```

è¿™é‡Œ `awaiter.await_ready()` è¿”å› `false`ï¼Œåç¨‹ä¼šè¢«æŒ‚èµ·ã€‚ä¹‹å `awaiter.await_suspend(handle)` è¢«æ‰§è¡Œï¼Œ`handle` ä¹Ÿå°±æ˜¯ä¸Šæ–‡æåˆ°çš„åç¨‹å¥æŸ„ã€‚è¯¥å‡½æ•°éœ€è¦å®Œæˆå¯¹å¥æŸ„çš„è°ƒåº¦ï¼Œä»¥ä¾¿ä¹‹åç”±æ‰§è¡Œå™¨å»æ¢å¤è¯¥åç¨‹æˆ–å°†å…¶é”€æ¯ã€‚è‹¥ `awaiter.await_suspend(handle)` çš„è¿”å›ç±»å‹ä¸º `void`ï¼Œ`co_await` ä¼šç«‹å³å°†æ‰§è¡Œæƒå½’è¿˜ç»™è°ƒç”¨è€…ã€‚ç›´åˆ° `handle.resume()` æ‰§è¡Œæ—¶ï¼Œåç¨‹æ‰ä¼šæ¢å¤æ‰§è¡Œï¼Œå¹¶ä¸”ä¼šè°ƒç”¨ `awaiter.await_resume()` å¹¶å°†å…¶è¿”å›å€¼ä½œä¸º `co_await awaiter` çš„è¿”å›å€¼ã€‚ä¸Šé¢çš„ä¾‹å­ä¸­å°†åç¨‹å¥æŸ„èµ‹å€¼ç»™äº†å…¨å±€å˜é‡ `handle`ï¼Œè€Œååç¨‹æŒ‚èµ·ï¼Œå›åˆ° `main` å‡½æ•°ï¼Œç¡çœ  1s åè°ƒç”¨ `handle.resume()` æ¢å¤ã€‚

`awaiter.await_suspend(handle)` æ‰§è¡Œå‰åç¨‹å·²å®ŒæˆæŒ‚èµ·ï¼Œæ­¤æ—¶åç¨‹çŠ¶æ€ä¸­å·²ç»ä¿å­˜äº†æ¢å¤æ‰€éœ€è¦çš„å„ç§çŠ¶æ€ï¼Œæ‰€ä»¥ä¹Ÿå¯ä»¥å°†åç¨‹å¥æŸ„ä¸¢åˆ°å¦ä¸€ä¸ªçº¿ç¨‹ä¸­æ¢å¤æ‰§è¡Œï¼Œå†çœ‹ä¸€ä¸ªä¾‹å­ğŸŒ°ï¼ˆ[åœ¨çº¿æ‰§è¡Œ](https://godbolt.org/z/MMnT6E)ï¼‰ï¼š

```c++
#include <coroutine>
#include <iostream>
#include <thread>

std::jthread thread;

struct Awaiter {
  Awaiter() {
    std::cout << "Awaiter()" << std::endl;
  }

  ~Awaiter() {
    std::cout << "~Awaiter()" << std::endl;
  }

  bool await_ready() {
    std::cout << "await ready or not" << std::endl;
    return false;
  }

  void await_resume() {
    std::cout << "await resumed" << std::endl;
  }

  void await_suspend(std::coroutine_handle<> h) {
    std::cout << "await suspended" << std::endl;

    thread = std::jthread([h] {
      std::this_thread::sleep_for(std::chrono::seconds(1));
      std::cout << "resume coroutine in another thread" << std::endl;
      h.resume();
    });
  }
};

struct Promise {
  struct promise_type {
    auto get_return_object() noexcept {
      std::cout << "get return object" << std::endl;
      return Promise();
    }

    auto initial_suspend() noexcept {
      std::cout << "initial suspend, return never" << std::endl;
      return std::suspend_never{};
    }

    auto final_suspend() noexcept {
      std::cout << "final suspend, return never" << std::endl;
      return std::suspend_never{};
    }

    void unhandled_exception() {
      std::cout << "unhandle exception" << std::endl;
      std::terminate();
    }

    void return_void() {
      std::cout << "return void" << std::endl;
      return;
    }
  };
};

Promise CoroutineFunc() {
  std::cout << "before co_await" << std::endl;
  co_await Awaiter();
  std::cout << "after co_await" << std::endl;
}

int main() {
  std::cout << "main() start" << std::endl;
  CoroutineFunc();
  std::cout << "main() exit" << std::endl;
}

/*
main() start
get return object
initial suspend, return never
before co_await
Awaiter()
await ready or not
await suspended
main() exit
resume coroutine in another thread
await resumed
~Awaiter()
after co_await
return void
final suspend, return never
*/
```

è¿™é‡Œåœ¨ `awaiter.await_suspend(handle)` ä¸­æ–°å»ºäº†ä¸€ä¸ª `std::jthread`ï¼Œè®¡åˆ’åœ¨çº¿ç¨‹ä¸­ç¡çœ  +1s åæ¢å¤åç¨‹ã€‚è€Œååç¨‹æŒ‚èµ·ï¼Œéšå `main` å‡½æ•°ç»“æŸï¼Œå…¨å±€å˜é‡ææ„ï¼Œç­‰å¾…çº¿ç¨‹ `join()` ã€‚äºæ˜¯ 1s åçº¿ç¨‹ç­‰å¾…ç»“æŸå¹¶æ¢å¤çº¿ç¨‹ã€‚æ³¨æ„ `awaiter` å¯¹è±¡åœ¨åç¨‹æ¢å¤åè‡ªåŠ¨ææ„äº†ã€‚

è¿™å‡ ä¸ªç®€å•çš„ä¾‹å­å°±å¯ä»¥æ¿€å‘å¤§é‡æƒ³è±¡åŠ›äº†ã€‚æ— æ ˆåç¨‹åŠ ä¸Šç¼–è¯‘å™¨åŠ æŒï¼Œä»¥å‰ç”¨é­”æ³•æ‰èƒ½å®Œæˆçš„äº‹æƒ…ç°åœ¨å¯ä»¥åœ¨å®˜æ–¹è®¤è¯ä¸‹è½»æ¾å®Œæˆã€‚å½“ç„¶ç›®å‰æ ‡å‡†ä¸­åªæä¾›äº†åç¨‹çš„åŸºç¡€èƒ½åŠ›ï¼Œå‰©ä¸‹è°ƒåº¦å™¨/æ‰§è¡Œå™¨ã€IO å¤šè·¯å¤ç”¨ç­‰éƒ½éœ€è¦ä½¿ç”¨è€…è‡ªè¡Œå®ç°ï¼ŒæœŸå¾…å¼€æºç¤¾åŒºå‡ºç°å®Œæ•´æ˜“ç”¨çš„å¼‚æ­¥æ¡†æ¶ï¼Œç›®å‰è§‚å¯Ÿåˆ° GitHub ä¸Šå·²ç»æœ‰ [folly/coro](https://github.com/facebook/folly/tree/master/folly/experimental/coro) å’Œ [libcopp](https://github.com/owt5008137/libcopp) åœ¨è¿›è¡Œç›¸å…³å·¥ä½œäº†ã€‚

### References

1. ["Coroutines (C++20)", *C++ Reference*](https://en.cppreference.com/w/cpp/language/coroutines)
2. ["Working Draft, C++ Extensions for Coroutines", *Open Standards*](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4775.pdf)

