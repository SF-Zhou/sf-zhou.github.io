# åˆæ¢ C++20 åç¨‹

å»å¹´å­¦ä¹  `libco` æ—¶å†™è¿‡ä¸€ç¯‡åšæ–‡ï¼Œ[è®²è¿°å¦‚ä½•ä½¿ç”¨æ±‡ç¼–å®ç°åç¨‹åˆ‡æ¢](/programming/cpp_magic_coroutine.html)ã€‚ä»Šå¹´å®˜æ–¹çš„åç¨‹å®ç°æ›´åŠ æˆç†Ÿï¼Œç¼–è¯‘å™¨åŸç”Ÿæ”¯æŒåŠ ä¸Šæ— æ ˆçš„è®¾è®¡éƒ½å¸å¼•ç€ç¬”è€…ï¼Œå³ä½¿å·¥ä½œä¸­æ²¡æ³•ç”¨ä¸Šä¹Ÿæƒ³ä¸€æ¢ç©¶ç«Ÿã€‚æœ€è¿‘ Mac ä¸Šå¯ä»¥ç›´æ¥é€šè¿‡ Homebrew å®‰è£… gcc 10.1 äº†ï¼Œå€Ÿæ­¤æœºä¼šæ¢ç´¢ä¸€ä¸‹ C++20 åç¨‹çš„ç©æ³•ã€‚

é¦–å…ˆå»ºè®®é˜…è¯»[å‚è€ƒæ–‡çŒ® 1](https://en.cppreference.com/w/cpp/language/coroutines)ï¼Œå¯ä»¥æ­é…æœ¬æ–‡ä¸­çš„å‡ ä¸ªä¾‹å­åŒæ­¥å­¦ä¹ ã€‚é¦–å…ˆçœ‹è¿™ä¸ªä¾‹å­ğŸŒ°ï¼ˆ[åœ¨çº¿æ‰§è¡Œ](https://godbolt.org/z/aGEo3j)ï¼‰ï¼š

```c++
#include <coroutine>
#include <iostream>

struct Awaiter {
  bool await_ready() {
    std::cout << "await ready or not" << std::endl;
    return true;
  }

  void await_resume() {
    std::cout << "await resumed" << std::endl;
  }

  void await_suspend(std::coroutine_handle<> h) {
    std::cout << "await suspended" << std::endl;
  }
};

struct Promise {
  struct promise_type {
    auto get_return_object() noexcept {
      std::cout << "get return object" << std::endl;
      return Promise();
    }

    auto initial_suspend() noexcept {
      std::cout << "initial suspend, return never" << std::endl;
      return std::suspend_never{};
    }

    auto final_suspend() noexcept {
      std::cout << "final suspend, return never" << std::endl;
      return std::suspend_never{};
    }

    void unhandled_exception() {
      std::cout << "unhandle exception" << std::endl;
      std::terminate();
    }

    void return_void() {
      std::cout << "return void" << std::endl;
      return;
    }
  };
};

Promise CoroutineFunc() {
  std::cout << "before co_await" << std::endl;
  co_await Awaiter();
  std::cout << "after co_await" << std::endl;
}

int main() {
  std::cout << "main() start" << std::endl;
  CoroutineFunc();
  std::cout << "main() exit" << std::endl;
}

/*
main() start
get return object
initial suspend, return never
before co_await
await ready or not
await resumed
after co_await
return void
final suspend, return never
main() exit
*/
```

å½“å‡½æ•°ä¸­ä½¿ç”¨ `co_await` / `co_yield` / `co_return` å…³é”®å­—æ—¶ï¼Œç¼–è¯‘å™¨ä¼šå°†è¯¥å‡½æ•°è¯†åˆ«ä¸ºåç¨‹ã€‚æ¯ä¸ªåç¨‹å‡½æ•°éƒ½éœ€è¦ä½¿ç”¨åç¨‹çŠ¶æ€ `coroutine state` æ¥å­˜å‚¨å†…éƒ¨æ•°æ®ï¼ŒåŒ…æ‹¬åç¨‹æ‰¿è¯º `promise`ã€ä¼ å…¥åç¨‹çš„å‚æ•°ã€å½“å‰æŒ‚èµ·ç‚¹çš„æŸç§è¡¨ç¤ºå½¢å¼ä»¥åŠå½“å‰æŒ‚èµ·ç‚¹èŒƒå›´å†…çš„å±€éƒ¨å˜é‡å’Œä¸´æ—¶å˜é‡ã€‚è¯¥çŠ¶æ€åˆ†é…åœ¨å †ä¸Šï¼Œç”±ç¼–è¯‘å™¨è´Ÿè´£ç®¡ç†ã€‚åç¨‹æ‰¿è¯º `promise` ç”±åç¨‹å†…éƒ¨æ§åˆ¶ï¼Œç”¨äºåç¨‹æäº¤ç»“æœæˆ–å¼‚å¸¸ï¼›åç¨‹å¥æŸ„ `coroutine handle` ç”±åç¨‹å¤–éƒ¨æ§åˆ¶ï¼Œç”¨äºæ¢å¤åç¨‹æ‰§è¡Œæˆ–é”€æ¯åç¨‹ï¼›äºŒè€…å¯ä»¥é€šè¿‡æ¥å£è·å–åˆ°å¯¹æ–¹ã€‚

å½“è°ƒç”¨åç¨‹å‡½æ•°æ—¶ï¼Œå…¶æ­¥éª¤å¦‚ä¸‹ï¼š

1. ä½¿ç”¨ `operator new` ç”³è¯·ç©ºé—´å¹¶åˆå§‹åŒ–åç¨‹çŠ¶æ€ï¼›
2. å¤åˆ¶åç¨‹å‚æ•°åˆ°åˆ°åç¨‹çŠ¶æ€ä¸­ï¼›
3. æ„é€ åç¨‹æ‰¿è¯ºå¯¹è±¡ `promise`ï¼›
4. è°ƒç”¨ `promise.get_return_object()` å¹¶å°†å…¶ç»“æœå­˜å‚¨åœ¨å±€éƒ¨å˜é‡ä¸­ã€‚è¯¥ç»“æœå°†ä¼šåœ¨åç¨‹é¦–æ¬¡æŒ‚èµ·æ—¶è¿”å›ç»™è°ƒç”¨è€…ï¼›
5. è°ƒç”¨ `co_await promise.initial_suspend()`ï¼Œé¢„å®šä¹‰äº† `std::suspend_always` è¡¨ç¤ºå§‹ç»ˆæŒ‚èµ·ï¼Œ`std::suspend_never` è¡¨ç¤ºå§‹ç»ˆä¸æŒ‚èµ·ï¼›
6. è€Œåæ­£å¼å¼€å§‹æ‰§è¡Œåç¨‹å‡½æ•°å†…è¿‡ç¨‹ã€‚

å½“åç¨‹å‡½æ•°æ‰§è¡Œåˆ° `co_return [expr]` è¯­å¥æ—¶ï¼š

1. è‹¥ `expr` ä¸º `void` åˆ™æ‰§è¡Œ `promise.return_void()`ï¼Œå¦åˆ™æ‰§è¡Œ `promise.return_value(expr)`ï¼›
2. æŒ‰ç…§åˆ›å»ºé¡ºåºçš„å€’åºé”€æ¯å±€éƒ¨å˜é‡å’Œä¸´æ—¶å˜é‡ï¼›
3. æ‰§è¡Œ `co_await promise.final_suspend()`ã€‚

å½“åç¨‹æ‰§è¡Œåˆ° `co_yield expr` è¯­å¥æ—¶ï¼š

1. æ‰§è¡Œ `co_await promise.yield_value(expr)`ã€‚

å½“åç¨‹æ‰§è¡Œåˆ° `co_await expr` è¯­å¥æ—¶ï¼š

1. é€šè¿‡ `expr` è·å¾— `awaiter` å¯¹è±¡ï¼›
2. æ‰§è¡Œ `awaiter.await_ready()`ï¼Œè‹¥ä¸º `true` åˆ™ç›´æ¥è¿”å› `awaiter.await_resume()`ï¼›
3. å¦åˆ™å°†åç¨‹æŒ‚èµ·å¹¶ä¿å­˜çŠ¶æ€ï¼Œæ‰§è¡Œ `awaiter.await_suspend()`ï¼Œè‹¥å…¶è¿”å›å€¼ä¸º `void` æˆ–è€… `true` åˆ™æˆåŠŸæŒ‚èµ·ï¼Œå°†æ§åˆ¶æƒè¿”è¿˜ç»™è°ƒç”¨è€… / æ¢å¤è€…ï¼›
4. ç›´åˆ° `handle.resume()` æ‰§è¡Œåè¯¥åç¨‹æ‰ä¼šæ¢å¤æ‰§è¡Œï¼Œå°† `awaiter.await_resume()` ä½œä¸ºè¡¨è¾¾å¼çš„è¿”å›å€¼ã€‚

å½“åç¨‹å› ä¸ºæŸä¸ªæœªæ•è·çš„å¼‚å¸¸å¯¼è‡´ç»ˆæ­¢æ—¶ï¼š

1. æ•è·å¼‚å¸¸å¹¶è°ƒç”¨ `promise.unhandled_exception()`ï¼›
2. è°ƒç”¨ `co_await promise.final_suspend()`ã€‚

å½“åç¨‹çŠ¶æ€é”€æ¯æ—¶ï¼ˆé€šè¿‡åç¨‹å¥æŸ„ä¸»åŠ¨é”€æ¯ / `co_return` è¿”å› / æœªæ•è·å¼‚å¸¸ï¼‰ï¼š

1. ææ„ `promise` å¯¹è±¡ï¼›
2. ææ„ä¼ å…¥çš„å‚æ•°ï¼›
3. å›æ”¶åç¨‹çŠ¶æ€å†…å­˜ã€‚

ç®€æ˜æ¥çœ‹ï¼Œä¸€ä¸ªåç¨‹å‡½æ•°ä¼šè¢«ç¼–è¯‘å™¨æ‰§è¡Œç±»ä¼¼ä¸‹æ–¹çš„å±•å¼€ï¼š

```c++
// åç¨‹å‡½æ•°
template <typename R, typename... Args>
R Func(Args... args) {
  auto ret = co_await Awaiter();
  co_yield ret;
  co_return;
}

// ç¼–è¯‘å™¨å±•å¼€
template <typename R, typename... Args>
R Func(Args... args) {
  using promise_t = typename coroutine_traits<R, Args...>::promise_type;

  promise_t promise;  // å®é™…ä¸Šåˆ†é…åœ¨å †ä¸Šè€Œéæ ˆä¸Šï¼Œè¿™é‡Œä¸ºäº†æ–¹ä¾¿è¯´æ˜ç®€åŒ–äº†
  auto __return__ = promise.get_return_object();

  co_await promise.initial_suspend();

  try {
    // auto ret = co_await Awaiter();
    auto &&value = Awaiter();
    auto &&awaitable = get_awaitable(promise, static_cast<decltype(value)>(value));
    auto &&awaiter = get_awaiter(static_cast<decltype(awaitable)>(awaitable));
    if (!awaiter.await_ready()) {
      using handle_t = std::coroutine_handle<Promise>;
      using await_suspend_result_t =
          decltype(awaiter.await_suspend(handle_t::from_promise(promise)));
      // åç¨‹æŒ‚èµ·
      if constexpr (std::is_void_v<await_suspend_result_t>) {
        awaiter.await_suspend(handle_t::from_promise(promise));
        return __return__;  // è¿”è¿˜æ§åˆ¶æƒç»™è°ƒç”¨è€…/æ¢å¤è€…
      } else {
        static_assert(std::is_same_v<await_suspend_result_t, bool>,
                      "await_suspend() must return 'void' or 'bool'.");
        if (awaiter.await_suspend(handle_t::from_promise(promise))) {
          return __return__;  // è¿”è¿˜æ§åˆ¶æƒç»™è°ƒç”¨è€…/æ¢å¤è€…
        }
      }
      // åç¨‹æ¢å¤ç‚¹ï¼Œhandle.resume() ååœ¨æ­¤å¤„æ¢å¤
    }
    auto ret = awaiter.await_resume();  // è¿”å› resume çš„å€¼

    // co_yield ret;
    co_await promise.yield_value(ret);

    // co_return;
    promise.return_void();
    goto final_suspend;
  } catch (...) {
    promise.set_exception(std::current_exception());
  }

final_suspend:
  co_await promise.final_suspend();
}
```

ç¬¬ä¸€ä¸ªæ ·ä¾‹ä¸­ `await_ready()` å§‹ç»ˆè¿”å› `true`ï¼Œåç¨‹å¹¶ä¸ä¼šæŒ‚èµ·è€Œæ˜¯ç»§ç»­åŒæ­¥æ‰§è¡Œç›´åˆ°ç»“æŸã€‚çœ‹å¦ä¸€ä¸ªä¾‹å­ğŸŒ°ï¼ˆ[åœ¨çº¿æ‰§è¡Œ](https://godbolt.org/z/soG5P1)ï¼‰ï¼š

```c++
#include <coroutine>
#include <iostream>
#include <thread>

std::coroutine_handle<> handle;

struct Awaiter {
  bool await_ready() {
    std::cout << "await ready or not" << std::endl;
    return false;
  }

  void await_resume() {
    std::cout << "await resumed" << std::endl;
  }

  void await_suspend(std::coroutine_handle<> h) {
    std::cout << "await suspended" << std::endl;
    handle = h;
  }
};

struct Promise {
  struct promise_type {
    auto get_return_object() noexcept {
      std::cout << "get return object" << std::endl;
      return Promise();
    }

    auto initial_suspend() noexcept {
      std::cout << "initial suspend, return never" << std::endl;
      return std::suspend_never{};
    }

    auto final_suspend() noexcept {
      std::cout << "final suspend, return never" << std::endl;
      return std::suspend_never{};
    }

    void unhandled_exception() {
      std::cout << "unhandle exception" << std::endl;
      std::terminate();
    }

    void return_void() {
      std::cout << "return void" << std::endl;
      return;
    }
  };
};

Promise CoroutineFunc() {
  std::cout << "before co_await" << std::endl;
  co_await Awaiter();
  std::cout << "after co_await" << std::endl;
}

int main() {
  std::cout << "main() start" << std::endl;
  CoroutineFunc();

  std::this_thread::sleep_for(std::chrono::seconds(1));
  std::cout << "resume coroutine after one second" << std::endl;
  handle.resume();

  std::cout << "main() exit" << std::endl;
}

/*
main() start
get return object
initial suspend, return never
before co_await
await ready or not
await suspended
resume coroutine after one second
await resumed
after co_await
return void
final suspend, return never
main() exit
*/
```

è¿™é‡Œ `awaiter.await_ready()` è¿”å› `false`ï¼Œåç¨‹ä¼šè¢«æŒ‚èµ·ã€‚ä¹‹å `awaiter.await_suspend(handle)` è¢«æ‰§è¡Œï¼Œ`handle` ä¹Ÿå°±æ˜¯ä¸Šæ–‡æåˆ°çš„åç¨‹å¥æŸ„ã€‚è¯¥å‡½æ•°éœ€è¦å®Œæˆå¯¹å¥æŸ„çš„è°ƒåº¦ï¼Œä»¥ä¾¿ä¹‹åç”±æ‰§è¡Œå™¨å»æ¢å¤è¯¥åç¨‹æˆ–å°†å…¶é”€æ¯ã€‚è‹¥ `awaiter.await_suspend(handle)` çš„è¿”å›ç±»å‹ä¸º `void`ï¼Œ`co_await` ä¼šç«‹å³å°†æ‰§è¡Œæƒå½’è¿˜ç»™è°ƒç”¨è€…ã€‚ç›´åˆ° `handle.resume()` æ‰§è¡Œæ—¶ï¼Œåç¨‹æ‰ä¼šæ¢å¤æ‰§è¡Œï¼Œå¹¶ä¸”ä¼šè°ƒç”¨ `awaiter.await_resume()` å¹¶å°†å…¶è¿”å›å€¼ä½œä¸º `co_await awaiter` çš„è¿”å›å€¼ã€‚ä¸Šé¢çš„ä¾‹å­ä¸­å°†åç¨‹å¥æŸ„èµ‹å€¼ç»™äº†å…¨å±€å˜é‡ `handle`ï¼Œè€Œååç¨‹æŒ‚èµ·ï¼Œå›åˆ° `main` å‡½æ•°ï¼Œç¡çœ  1s åè°ƒç”¨ `handle.resume()` æ¢å¤ã€‚

`awaiter.await_suspend(handle)` æ‰§è¡Œå‰åç¨‹å·²å®ŒæˆæŒ‚èµ·ï¼Œæ­¤æ—¶åç¨‹çŠ¶æ€ä¸­å·²ç»ä¿å­˜äº†æ¢å¤æ‰€éœ€è¦çš„å„ç§çŠ¶æ€ï¼Œæ‰€ä»¥ä¹Ÿå¯ä»¥å°†åç¨‹å¥æŸ„ä¸¢åˆ°å¦ä¸€ä¸ªçº¿ç¨‹ä¸­æ¢å¤æ‰§è¡Œï¼Œå†çœ‹ä¸€ä¸ªä¾‹å­ğŸŒ°ï¼ˆ[åœ¨çº¿æ‰§è¡Œ](https://godbolt.org/z/MMnT6E)ï¼‰ï¼š

```c++
#include <coroutine>
#include <iostream>
#include <thread>

std::jthread thread;

struct Awaiter {
  Awaiter() {
    std::cout << "Awaiter()" << std::endl;
  }

  ~Awaiter() {
    std::cout << "~Awaiter()" << std::endl;
  }

  bool await_ready() {
    std::cout << "await ready or not" << std::endl;
    return false;
  }

  void await_resume() {
    std::cout << "await resumed" << std::endl;
  }

  void await_suspend(std::coroutine_handle<> h) {
    std::cout << "await suspended" << std::endl;

    thread = std::jthread([h] {
      std::this_thread::sleep_for(std::chrono::seconds(1));
      std::cout << "resume coroutine in another thread" << std::endl;
      h.resume();
    });
  }
};

struct Promise {
  struct promise_type {
    auto get_return_object() noexcept {
      std::cout << "get return object" << std::endl;
      return Promise();
    }

    auto initial_suspend() noexcept {
      std::cout << "initial suspend, return never" << std::endl;
      return std::suspend_never{};
    }

    auto final_suspend() noexcept {
      std::cout << "final suspend, return never" << std::endl;
      return std::suspend_never{};
    }

    void unhandled_exception() {
      std::cout << "unhandle exception" << std::endl;
      std::terminate();
    }

    void return_void() {
      std::cout << "return void" << std::endl;
      return;
    }
  };
};

Promise CoroutineFunc() {
  std::cout << "before co_await" << std::endl;
  co_await Awaiter();
  std::cout << "after co_await" << std::endl;
}

int main() {
  std::cout << "main() start" << std::endl;
  CoroutineFunc();
  std::cout << "main() exit" << std::endl;
}

/*
main() start
get return object
initial suspend, return never
before co_await
Awaiter()
await ready or not
await suspended
main() exit
resume coroutine in another thread
await resumed
~Awaiter()
after co_await
return void
final suspend, return never
*/
```

è¿™é‡Œåœ¨ `awaiter.await_suspend(handle)` ä¸­æ–°å»ºäº†ä¸€ä¸ª `std::jthread`ï¼Œè®¡åˆ’åœ¨çº¿ç¨‹ä¸­ç¡çœ  +1s åæ¢å¤åç¨‹ã€‚è€Œååç¨‹æŒ‚èµ·ï¼Œéšå `main` å‡½æ•°ç»“æŸï¼Œå…¨å±€å˜é‡ææ„ï¼Œç­‰å¾…çº¿ç¨‹ `join()` ã€‚äºæ˜¯ 1s åçº¿ç¨‹ç­‰å¾…ç»“æŸå¹¶æ¢å¤çº¿ç¨‹ã€‚æ³¨æ„ `awaiter` å¯¹è±¡åœ¨åç¨‹æ¢å¤åè‡ªåŠ¨ææ„äº†ã€‚

è¿™å‡ ä¸ªç®€å•çš„ä¾‹å­å°±å¯ä»¥æ¿€å‘å¤§é‡æƒ³è±¡åŠ›äº†ã€‚æ— æ ˆåç¨‹åŠ ä¸Šç¼–è¯‘å™¨åŠ æŒï¼Œä»¥å‰ç”¨é­”æ³•æ‰èƒ½å®Œæˆçš„äº‹æƒ…ç°åœ¨å¯ä»¥åœ¨å®˜æ–¹è®¤è¯ä¸‹è½»æ¾å®Œæˆã€‚å½“ç„¶ç›®å‰æ ‡å‡†ä¸­åªæä¾›äº†åç¨‹çš„åŸºç¡€èƒ½åŠ›ï¼Œå‰©ä¸‹è°ƒåº¦å™¨/æ‰§è¡Œå™¨ã€IO å¤šè·¯å¤ç”¨ç­‰éƒ½éœ€è¦ä½¿ç”¨è€…è‡ªè¡Œå®ç°ï¼ŒæœŸå¾…å¼€æºç¤¾åŒºå‡ºç°å®Œæ•´æ˜“ç”¨çš„å¼‚æ­¥æ¡†æ¶ï¼Œç›®å‰è§‚å¯Ÿåˆ° GitHub ä¸Šå·²ç»æœ‰ [folly/coro](https://github.com/facebook/folly/tree/master/folly/experimental/coro) å’Œ [libcopp](https://github.com/owt5008137/libcopp) åœ¨è¿›è¡Œç›¸å…³å·¥ä½œäº†ã€‚

### References

1. ["Coroutines (C++20)", *C++ Reference*](https://en.cppreference.com/w/cpp/language/coroutines)
2. ["Working Draft, C++ Extensions for Coroutines", *Open Standards*](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4775.pdf)
3. ["C++ Coroutine ç®€æ˜æ•™ç¨‹", *wpcockroach*](https://www.cnblogs.com/wpcockroach/p/7403460.html)
4. ["C++ Coroutines: Understanding operator `co_await`", *lewissbaker*](https://lewissbaker.github.io/2017/11/17/understanding-operator-co-await)

