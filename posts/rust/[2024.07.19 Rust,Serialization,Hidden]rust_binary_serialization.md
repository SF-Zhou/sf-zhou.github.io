# Rust 二进制序列化

最近在做 Rust RDMA RPC 框架，需要一套二进制序列化库。因为对 Rust 编程中的范型和宏不是太熟悉，所以刚好自己做一套用以练手。本文简述一下该序列化库的设计方案。

### 1. 二进制格式

序列化的二进制格式参考我原先做的 C++ 库，大概原则是这样的：

1. 所有字段仅保留值，不记录类型信息，不进行任何对齐操作；
2. 数值直接使用小端存储；
3. String/Vec 先序列化其长度，再序列化具体内容；
4. 各类长度信息使用 VarInt 存储以减少长度；
5. 对结构体，先序列化整个序列化结果的长度，再依次序列化所有字段。

反序列化时，则按顺序反序列化即可。举例：

```rust
struct A {
  x: String,
  y: i32
}

struct B {
  a: A,
  b: u64,
}

// 以下是一个 B 类型对象的序列化结果
data = [0x1a, 0x11, 0x0c, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x77, 0x6f, 0x72, 0x6c, 0x64, 0x21, 0x20, 0x00, 0x00, 0x00, 0xe9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];

data = [
  0x1a, // B 类型各个字段序列化的总长度为 26
    // 第一个字段：结构体 a
    0x11, // A 类型各个字段序列化的总长度为 17
      // 第一个字段：String
      0x0c, // 字符串的长度为 12
        // 解析字符串，得到 hello world
        0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x77, 0x6f, 0x72, 0x6c, 0x64, 0x21,
      // 第二个字段：i32
      0x20, 0x00, 0x00, 0x00, // 小端解析得到数字 32
    // 第二个字段：u64
    0xe9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 小端解析得到数字 233
]
```

### 2. 定义和实现

实现这样的序列化似乎并不复杂：

1. 对数值来说，可以直接调用 `&x.to_le_bytes()` 获得 `&[u8]`
2. 对字符串来说，可以直接调用 `x.as_bytes()` 获得 `&[u8]`
3. 对于结构体，按顺序将每个字符转为 `&[u8]`，拼接上长度即可
4. 对于类似 `Vec<Item>` 这样的容器，按顺序将每个 `Item` 转为 `&[u8]` 即可

所以需要一个容器，用以存储序列化的结果。并且该容器最好是可以用户自定义的，故这里定义一个 `Serializier` 的 trait 用以表征承载序列化结果的容器。考虑上一节中提到的第 5 条，因为结构体序列化的长度是记录在最前方的，而该长度又是变长的，我们无法在序列化完成前轻松地获得该长度，所以需要先序列化所有字段，再序列化该长度。所以 `Serializier` 的定义如下：

```rust
pub trait Serializer {
    fn prepend(&mut self, data: impl AsRef<[u8]>) -> Result<()>;
    fn len(&self) -> usize;
}
```

对于序列化操作本身，定义一个 `Serialize` 的 trait：

```rust
pub trait Serialize {
    fn serialize<S: Serializer + Default>(&self) -> Result<S> {
        let mut serializer = S::default();
        self.serialize_to(&mut serializer)?;
        Ok(serializer)
    }

    fn serialize_to<S: Serializer>(&self, serializer: &mut S) -> Result<()>;
}
```

