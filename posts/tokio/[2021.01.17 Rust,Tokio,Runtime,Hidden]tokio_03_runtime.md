# Tokio 源码分析「三、运行时 Runtime」

Tokio 的核心是一套 M:N 的协程 Runtime，下层通过 Rust 协程和 Mio 驱动，支撑上层的 HTTP / RPC 应用。本篇开始分析 Runtime，代码版本 [v1.0.2](https://github.com/tokio-rs/tokio/tree/tokio-1.0.2)。

![Tokio 架构图 from tokio.rs](../images/5e364463cf50f41fec2e028df84f6a4a.svg)

### 1. 概览

在阅读核心代码前，先介绍一下异步编程中的核心关键字：

**Asynchrony**：异步指事件的发生与主程序流及处理此类事件的方式无关。这些事件可能是像信号这样的外部事件，或者是由程序引发的动作，会和程序的执行同时发生，而程序不会阻塞地等待结果。简而言之，事件发生在非调用方的线程中。同步与异步关注的是事件是否是在本线程中处理。

**Non-blocking**：非阻塞指执行的操作不会阻塞程序的继续执行。阻塞与非阻塞关注的是调用方等待结果时的状态。阻塞非阻塞和同步异步是正交的，即存在同步阻塞、同步非阻塞、异步阻塞、异步非阻塞。

**Resumable Function**：可恢复函数指可以暂停执行并从调用中返回，并且可以在将来从暂停的位置恢复执行的函数。可恢复函数是协程的基石。

**Asynchronous Runtime**：异步运行时，上述概念的整合，通过可恢复函数、挂起位置埋点和用户态调度实现非抢占式的用户态线程切换，称之为协程。一般将同步阻塞 IO 的位置作为默认的挂起位置。

Tokio 库的代码量十分巨大，[`tokio/src`](https://github.com/tokio-rs/tokio/tree/tokio-1.0.2/tokio/src) 目录下共计 242 个代码文件，行数 5w+。核心代码的文件结构为：

```
tokio/src
├── blocking.rs
├── coop.rs
├── fs
├── future
├── io
├── lib.rs
├── loom
├── macros
├── net
├── park
├── process
├── runtime
├── signal
├── sync
├── task
├── time
└── util
```

再来看官方提供的样例：

```rust
use tokio::net::TcpListener;
use tokio::io::{AsyncReadExt, AsyncWriteExt};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut listener = TcpListener::bind("127.0.0.1:8080").await?;

    loop {
        let (mut socket, _) = listener.accept().await?;

        tokio::spawn(async move {
            let mut buf = [0; 1024];

            // In a loop, read data from the socket and write the data back.
            loop {
                let n = match socket.read(&mut buf).await {
                    // socket closed
                    Ok(n) if n == 0 => return,
                    Ok(n) => n,
                    Err(e) => {
                        eprintln!("failed to read from socket; err = {:?}", e);
                        return;
                    }
                };

                // Write the data back
                if let Err(e) = socket.write_all(&buf[0..n]).await {
                    eprintln!("failed to write to socket; err = {:?}", e);
                    return;
                }
            }
        });
    }
}
```

如果之前接触过协程和网络编程，肯定会赞叹上方 Echo Server 的高效和简洁。

### 2. `tokio/runtime/task`

Tokio 的 Runtime 提供以下能力：

> - An **I/O event loop**, called the driver, which drives I/O resources and dispatches I/O events to tasks that depend on them.
> - A **scheduler** to execute [tasks](https://docs.rs/tokio/0.2.24/tokio/task/index.html) that use these I/O resources.
> - A **timer** for scheduling work to run after a set period of time.

这一节来看任务 `task` 相关的抽象，代码路径为 [tokio/src/runtime/task](https://github.com/tokio-rs/tokio/tree/tokio-1.0.2/tokio/src/runtime/task)。先看任务状态 [`state.rs`](https://github.com/tokio-rs/tokio/blob/tokio-1.0.2/tokio/src/runtime/task/state.rs)：

```rust
// State 本身是原子无符号数
pub(super) struct State {
    val: AtomicUsize,
}

// Snapshot 是从 State 读取到的值
#[derive(Copy, Clone)]
pub(super) struct Snapshot(usize)

// 更新 State 时的 Result，成功返回更新后的 Snapshot
type UpdateResult = Result<Snapshot, Snapshot>;

// State 实际的编码，包括一个引用计数
const RUNNING: usize = 0b0001;       // 是否在运行
const COMPLETE: usize = 0b0010;      // 是否已完成
const LIFECYCLE_MASK: usize = 0b11;
const NOTIFIED: usize = 0b100;       // task 是否已经加入运行队列
const JOIN_INTEREST: usize = 0b1_000;
const JOIN_WAKER: usize = 0b10_000;
const CANCELLED: usize = 0b100_000;  // 任务被取消
const STATE_MASK: usize = LIFECYCLE_MASK | NOTIFIED | JOIN_INTEREST | JOIN_WAKER | CANCELLED;  // 所有状态相关的位

const REF_COUNT_MASK: usize = !STATE_MASK;   // 引用计数使用的位
const REF_COUNT_SHIFT: usize = REF_COUNT_MASK.count_zeros() as usize;
const REF_ONE: usize = 1 << REF_COUNT_SHIFT;  // 引用计数中的 1

const INITIAL_STATE: usize = (REF_ONE * 2) | JOIN_INTEREST | NOTIFIED;  // 初始化状态，scheduler 和 `JoinHandle` 会引用它

impl State {
    pub(super) fn new() -> State {
        State {
            val: AtomicUsize::new(INITIAL_STATE),
        }
    }

    // 读取当前的状态，使用 Acquire Ordering
    pub(super) fn load(&self) -> Snapshot {
        Snapshot(self.val.load(Acquire))
    }

    // 使用 CAS 实现线程安全的状态转移，转移失败时返回当前的状态
    fn fetch_update<F>(&self, mut f: F) -> Result<Snapshot, Snapshot>
    where
        F: FnMut(Snapshot) -> Option<Snapshot>,
    {
        let mut curr = self.load();

        loop {
            let next = match f(curr) {
                Some(next) => next,
                None => return Err(curr),
            };

            let res = self.val.compare_exchange(curr.0, next.0, AcqRel, Acquire);

            match res {
                Ok(_) => return Ok(next),
                Err(actual) => curr = Snapshot(actual),
            }
        }
    }

    // 尝试转移到 running 状态
    pub(super) fn transition_to_running(&self, ref_inc: bool) -> UpdateResult {
        self.fetch_update(|curr| {
            assert!(curr.is_notified());

            let mut next = curr;

            if !next.is_idle() {
                return None;
            }

            if ref_inc {
                next.ref_inc();
            }

            next.set_running();
            next.unset_notified();
            Some(next)
        })
    }

    // 增加引用计数
    pub(super) fn ref_inc(&self) {
        use std::process;
        use std::sync::atomic::Ordering::Relaxed;

        let prev = self.val.fetch_add(REF_ONE, Relaxed);

        // If the reference count overflowed, abort.
        if prev > isize::max_value() as usize {
            process::abort();
        }
    }
}

// Snapshot 提供状态读写的街口
impl Snapshot {
    pub(super) fn is_running(self) -> bool {
        self.0 & RUNNING == RUNNING
    }

    fn set_running(&mut self) {
        self.0 |= RUNNING;
    }
    ...
}
```



### References

1. ["Announcing Tokio 1.0", *tokio.rs*](https://tokio.rs/blog/2020-12-tokio-1-0)
2. ["Asynchrony (computer programming)", *Wikipedia*](https://en.wikipedia.org/wiki/Asynchrony_(computer_programming))
3. ["Asynchronous I/O", *Wikipedia*](https://en.wikipedia.org/wiki/Asynchronous_I/O)
4. ["async is not nonblocking", *Wikipedia*](https://en.wikipedia.org/wiki/Talk:Asynchronous_I/O#async_is_not_nonblocking)

