# Rust RDMA 编程「四、收发控制」

### 1. 背景

RDMA 编程中，常用的通信操作有 Read/Write 和 Send/Recv。前者是单向操作，即发起端可以直接读写远端的内存，不需要远端的 CPU 参与；后者是双向操作，发起端 Send 需要搭配远端 Recv，类似 TCP 通信。Read/Write 使用上会更简单，但在发起操作前需要知道远端内存的地址，所以正常情况下无法单独使用，一般需要搭配 Send/Recv 实现的控制流，才能完成 Read/Write 实现的数据流。

所以实现高性能的 RDMA 通信仍需要先实现高性能的 Send/Recv。但与 TCP 通信不同的是，RDMA Send 一定需要远端已经发起了 Recv 操作，否则 Send 操作会直接失败。这就需要我们实现一套良好的收发控制策略，使得 Send 操作可以高效且安全地被提交。

整理 Send 相关的限制条件：

1. 本地 Send Queue 的 `max_send_wr`，限制提交到该发送队列的 WR 的最大数量，WR 的类型包含 Send/Read/Write 操作
2. 远端 Recv Queue 中提交的未完成的 Recv 操作数量
3. 本地 Completion Queue 的大小，如果完成的 WR 累积在完成队列中没有被消费也会引发错误