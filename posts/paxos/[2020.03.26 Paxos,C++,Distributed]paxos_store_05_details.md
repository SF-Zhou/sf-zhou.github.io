# PaxosStore 源码分析「五、实现细节」

> Work in Progress

本系列的上一篇里分析了 PaxosStore 中的协议日志的实现，本篇将深入协议过程中的一些细节，这些实现细节集中在 [`src/EntityWorker.cpp`](https://github.com/Tencent/paxosstore/blob/master/certain/src/EntityWorker.cpp) 这个庞然大物里。

### 1. EntityCatchUp

在对某个 Entity 执行读写前，需要保证该 Entity 在本地的所有 Entry 都已经提交到 DB 了，这样读写才会有意义。简而言之就是 `CommittedEntry` = `MaxChosenEntry`。

借此机会，过一遍样例的流程。从 [`example/CardTool.cpp`](https://github.com/Tencent/paxosstore/blob/master/certain/example/CardTool.cpp) 这个 Client 开始看：

```c++
int main(int argc, char **argv) {
  ...
  Run(strAddr, strOper, oRequest, oResponse, &vecIPList);
  ...
}

grpc::Status Run(const std::string &strAddr, const std::string &strOper,
                 example::CardRequest &oRequest, example::CardResponse &oResponse,
                 std::vector<std::string> *poIPList) {
  ...
  switch (strOper[0]) {
    case 'I':
      oRequest.set_entity_id(GetEntityID(oRequest.card_id()));
      oRequest.mutable_card_info()->set_last_modified_time(time(0));
      oStatus = oClient.Call(oRequest.entity_id(), example::eInsertCard, &oRequest, &oResponse);
      break;
  }
  ...
}
```

该 Client 会调用 gRPC 向 Server 发送请求，直接看 Server 端的处理函数 [`example/ServiceImpl.cpp`](https://github.com/Tencent/paxosstore/blob/master/certain/example/ServiceImpl.cpp)：

```c++
int clsServiceImpl::InsertCard(grpc::ServerContext &oContext, const example::CardRequest &oRequest,
                               example::CardResponse &oResponse) {
  return BatchFunc(example::OperCode::eInsertCard, oRequest, oResponse);
}

int clsServiceImpl::BatchFunc(int iOper, const example::CardRequest &oRequest,
                              example::CardResponse &oResponse) {
  uint64_t iStartUS = Certain::GetCurrTimeUS();

  // 1. 将请求构造为 QueueItem，压入队列，压入 BatchMap
  uint64_t iPushStartUS = Certain::GetCurrTimeUS();
  QueueItem_t *poItem = new QueueItem_t;
  Certain::clsAutoDelete<QueueItem_t> oAutoDelete(poItem);
  poItem->iOper = iOper;
  poItem->iEntityID = oRequest.entity_id();
  poItem->poRequest = (void *)&oRequest;
  poItem->poResponse = (void *)&oResponse;
  poItem->iRet = BatchStatus::WAITING;

  {
    Certain::clsThreadLock oLock(&m_poBatchMapMutex);
    m_oBatchMap[poItem->iEntityID].push(poItem);
  }
  uint64_t iPushEndUS = Certain::GetCurrTimeUS();

  // 2. 上锁，同一个 EntityID 的请求都会在队列里
  uint64_t iLockStartUS = Certain::GetCurrTimeUS();
  Certain::clsAutoEntityLock oAuto(poItem->iEntityID);

  if (poItem->iRet != BatchStatus::WAITING) {
    return poItem->iRet;
  }

  clsDBImpl *poDBEngine =
      dynamic_cast<clsDBImpl *>(Certain::clsCertainWrapper::GetInstance()->GetDBEngine());
  dbtype::DB *poDB = poDBEngine->GetDB();
  clsTemporaryTable oTable(poDB);
  uint64_t iLockEndUS = Certain::GetCurrTimeUS();

  // 3. 将具有相同 EntityID 的请求弹出
  uint64_t iPopStartUS = Certain::GetCurrTimeUS();
  std::queue<QueueItem_t *> oQueue;
  {
    Certain::clsThreadLock oLock(&m_poBatchMapMutex);
    auto iter = m_oBatchMap.find(poItem->iEntityID);
    assert(iter != m_oBatchMap.end());
    while (!iter->second.empty()) {
      oQueue.push(iter->second.front());
      iter->second.pop();
    }
  }
  uint64_t iPopEndUS = Certain::GetCurrTimeUS();

  // 4. 该 EntityID 执行 EntityCatchUp，如果失败则统一返回
  uint64_t iCatchUpStartUS = Certain::GetCurrTimeUS();
  Certain::clsCertainWrapper *poCertain = Certain::clsCertainWrapper::GetInstance();
  uint64_t iEntry = 0, iMaxCommitedEntry = 0;
  int iRet = poCertain->EntityCatchUp(poItem->iEntityID, iMaxCommitedEntry);
  if (iRet != 0) {
    BatchReturn(&oQueue, iRet);
    return iRet;
  }
  uint64_t iCatchUpEndUS = Certain::GetCurrTimeUS();

  // 5. 遍历所有请求，执行 HandleSingleCommand
  uint64_t iBatchHandleStartUS = Certain::GetCurrTimeUS();
  std::vector<uint64_t> vecUUID;
  uint64_t iQueueSize = oQueue.size();
  uint64_t iRead = 0, iWrite = 0;
  while (iQueueSize > 0) {
    QueueItem_t *poItem = oQueue.front();
    oQueue.pop();
    --iQueueSize;

    assert(poItem->iRet == BatchStatus::WAITING);
    HandleSingleCommand(&oTable, poItem, &vecUUID);
    if (poItem->iOper == example::OperCode::eSelectCard)
      iRead++;
    else
      iWrite++;
    // Re-push items since they need to RunPaxos.
    oQueue.push(poItem);
  }
  uint64_t iBatchHandleEndUS = Certain::GetCurrTimeUS();

  // 6. 跑 Paxos 协议，批量返回
  uint64_t iRunPaxosStartUS = Certain::GetCurrTimeUS();
  iEntry = iMaxCommitedEntry + 1;
  iRet = poCertain->RunPaxos(poItem->iEntityID, iEntry, example::OperCode::eBatchFunc, vecUUID,
                             oTable.GetWriteBatchString());
  BatchReturn(&oQueue, iRet);
  uint64_t iRunPaxosEndUS = Certain::GetCurrTimeUS();

  uint64_t iEndUS = Certain::GetCurrTimeUS();

  // 7. 提供成功则执行提交
  if (iRet == 0) {
    poDBEngine->Commit(poItem->iEntityID, iEntry, oTable.GetWriteBatchString());
  }

  CertainLogInfo(
      "iEntityID %lu iPushTime %lu iLockTime %lu iPopTime %lu "
      "iCatchUpTime %lu iBatchHandleTime %lu iRunPaxos %lu iTotalUS %lu "
      "iRead %lu iWrite %lu",
      poItem->iEntityID, iPushEndUS - iPushStartUS, iLockEndUS - iLockStartUS,
      iPopEndUS - iPopStartUS, iCatchUpEndUS - iCatchUpStartUS,
      iBatchHandleEndUS - iBatchHandleStartUS, iRunPaxosEndUS - iRunPaxosStartUS, iEndUS - iStartUS,
      iRead, iWrite);

  iRet = poItem->iRet;
  return iRet;
}
```

注意步骤 4 中的 `EntityCatchUp`，在跑 `Paxos` 协议前会先确定本地所有的 Entry 已经提交到 DB。注意这里并不保证也不需要保证 Entry 是全局最新的，因为如果不是，跑协议的过程中会失败、然后触发 CatchUp，之后的博文会分析该过程。

来看 `EntityCatchUp` 的实现，位于 [`src/CertainWrapper.cpp`](https://github.com/Tencent/paxosstore/blob/master/certain/src/CertainWrapper.cpp#L64)：

```c++
int clsCertainWrapper::EntityCatchUp(uint64_t iEntityID, uint64_t &iMaxCommitedEntry) {
  const uint32_t iMaxCommitNum = GetConf()->GetMaxCommitNum();

  uint32_t iCommitCnt = 0;

  uint64_t iEntry = 0;
  std::string strWriteBatch;

  uint32_t iFlag = 0;
  iMaxCommitedEntry = 0;
  // 从 Data DB 中读取 MaxCommitedEntry
  int iRet = m_poDBEngine->GetEntityMeta(iEntityID, iMaxCommitedEntry, iFlag);
  if (iRet != 0 && iRet != eRetCodeNotFound) {
    CertainLogError("iEntityID %lu GetEntityMeta ret %d", iEntityID, iRet);
    return iRet;
  }

  // 至多尝试 iMaxCommitNum 次 Commit
  while (iCommitCnt < iMaxCommitNum) {
    // 检查 DB 状态
    iRet = CheckDBStatus(iEntityID, iMaxCommitedEntry);
    if (iRet == eRetCodeOK) {
      break;
    } else if (iRet != eRetCodeDBLagBehind) {
      CertainLogError("CheckDBStatus iEntityID %lu ret %d", iEntityID, iRet);
      return iRet;
    }

    iEntry = iMaxCommitedEntry + 1;

    OSS::ReportGetAndCommit();

    // 从 PLog 中获取 iMaxCommitedEntry 下一个的 Record
    iRet = GetWriteBatch(iEntityID, iEntry, strWriteBatch);
    if (iRet != 0) {
      CertainLogError("E(%lu, %lu) GetWriteBatch ret %d", iEntityID, iEntry, iRet);
      return iRet;
    }

    TIMERMS_START(iCommitUseTimeMS);
    // 将该 Record 提交到 Data DB
    iRet = m_poDBEngine->Commit(iEntityID, iEntry, strWriteBatch);
    TIMERMS_STOP(iCommitUseTimeMS);
    OSS::ReportDBCommit(iRet, iCommitUseTimeMS);
    if (iRet != 0) {
      CertainLogError("E(%lu, %lu) Commit ret %d", iEntityID, iEntry, iRet);
      return iRet;
    }

    iCommitCnt++;
    iMaxCommitedEntry++;
  }

  if (iCommitCnt == iMaxCommitNum && CheckDBStatus(iEntityID, iMaxCommitedEntry) != eRetCodeOK) {
    CertainLogError("iEntityID %lu iCommitCnt == iMaxCommitNum %u", iEntityID, iMaxCommitNum);
    return Certain::eRetCodeDBCommitLimited;
  }

  return 0;
}

int clsCertainWrapper::CheckDBStatus(uint64_t iEntityID, uint64_t iCommitedEntry) {
  uint64_t iMaxContChosenEntry = 0;
  uint64_t iMaxChosenEntry = 0;
  uint64_t iLeaseTimeoutMS = 0;

  bool bTriggleRecovered = false;

  // 从内存中读取 Entity 对应的 iMaxContChosenEntry 和 iMaxChosenEntry 信息
  int iRet = m_poEntityGroupMng->GetMaxChosenEntry(iEntityID, iMaxContChosenEntry, iMaxChosenEntry,
                                                   iLeaseTimeoutMS);
  if (iRet == eRetCodeNotFound) {
    // 内存中没有查询到该 EntityID 的信息，则通过 PLog 恢复
    bTriggleRecovered = true;

    // 构造一条 Recover Cmd
    clsRecoverCmd *poCmd = new clsRecoverCmd(iEntityID, iCommitedEntry);
    clsAutoDelete<clsRecoverCmd> oAuto(poCmd);

    poCmd->SetTimestampUS(GetCurrTimeUS());

    // 发送一条 Recover Cmd 并等待结果
    iRet = SyncWaitCmd(poCmd);
    if (iRet != 0) {
      CertainLogError("iEntityID %lu SyncWaitCmd ret %d", iEntityID, iRet);
      return iRet;
    }

    // 从 Recover Cmd 的结果中读取 iMaxContChosenEntry 和 iMaxChosenEntry
    iMaxContChosenEntry = poCmd->GetMaxContChosenEntry();
    iMaxChosenEntry = poCmd->GetMaxChosenEntry();
  } else if (iRet != 0) {
    CertainLogError("iEntityID %lu GetMaxChosenEntry iRet %d", iEntityID, iRet);
    return iRet;
  } else if (iLeaseTimeoutMS > 0) {
    // 租约相关，以后再分析
    OSS::ReportLeaseWait();
    poll(NULL, 0, iLeaseTimeoutMS);

    CertainLogError("iEntityID %lu wait iLeaseTimeoutMS %lu", iEntityID, iLeaseTimeoutMS);

    iRet = m_poEntityGroupMng->GetMaxChosenEntry(iEntityID, iMaxContChosenEntry, iMaxChosenEntry,
                                                 iLeaseTimeoutMS);
    if (iRet != 0) {
      CertainLogError("iEntityID %lu iLeaseTimeoutMS %lu ret %d", iEntityID, iLeaseTimeoutMS, iRet);
      return iRet;
    }
  }

  // iMaxContChosenEntry may update posterior to iCommitedEntry.
  if (iMaxContChosenEntry < iCommitedEntry) {
    iMaxContChosenEntry = iCommitedEntry;
  }

  if (iCommitedEntry + m_poConf->GetMaxCatchUpNum() <= iMaxContChosenEntry) {
    // All entrys of the entity are eliminated, help trigger db catchup.
    if (iMaxContChosenEntry == iMaxChosenEntry) {
      CertainLogError("notify_db iEntityID %lu entrys: %lu %lu", iEntityID, iCommitedEntry,
                      iMaxContChosenEntry);
      // 通知 DBWorker 异步做恢复
      clsDBWorker::NotifyDBWorker(iEntityID);
    }

    CertainLogError("iEntityID %lu entrys: %lu %lu %lu", iEntityID, iCommitedEntry,
                    iMaxContChosenEntry, iMaxChosenEntry);
    if (!bTriggleRecovered) {
      // 触发 Recover，同样也是发送一条 Recover Cmd
      TriggeRecover(iEntityID, iCommitedEntry);
    }
    return eRetCodeCatchUp;
  }

  // 本地的 Chosen 小于全局的 Chosen，先追赶上全局的进度
  if (iMaxContChosenEntry < iMaxChosenEntry) {
    CertainLogError("iEntityID %lu entrys: %lu %lu %lu", iEntityID, iCommitedEntry,
                    iMaxContChosenEntry, iMaxChosenEntry);
    if (!bTriggleRecovered) {
      // 触发 Recover
      TriggeRecover(iEntityID, iCommitedEntry);
    }
    return eRetCodeCatchUp;
  }

  if (iCommitedEntry >= iMaxChosenEntry) {
    // 只有 Committed 和 Chosen 一致，DB 才是本地最新的
    return eRetCodeOK;
  } else {
    // 否则 Committed 需要追赶
    return eRetCodeDBLagBehind;
  }
}

int clsCertainWrapper::GetWriteBatch(uint64_t iEntityID, uint64_t iEntry, string &strWriteBatch,
                                     uint64_t *piValueID) {
  EntryRecord_t tRecord;
  // 从 PLog 中读取对应的 Record
  int iRet = m_poPLogEngine->GetRecord(iEntityID, iEntry, tRecord);
  if (iRet != 0) {
    if (iRet != eRetCodeNotFound) {
      CertainLogFatal("BUG probably E(%lu, %lu) ret %d", iEntityID, iEntry, iRet);
      return iRet;
    }

    CertainLogInfo("E(%lu, %lu) not found", iEntityID, iEntry);
    return eRetCodeNotFound;
  }

  // 要确定已经 Chosen 了
  if (!tRecord.bChosen) {
    CertainLogInfo("unchosen: %s", EntryRecordToString(tRecord).c_str());
    return eRetCodeNotFound;
  }

  if (piValueID != NULL) {
    *piValueID = tRecord.tValue.iValueID;
  }

  // 拿到已经 Chosen 的 WriteBatch
  strWriteBatch = tRecord.tValue.strValue;

  return 0;
}
```

这里有几个进度：

1. 已经提交到 Data DB 的进度：`CommittedEntry`
2. 获取到的最大 Chosen 进度：`MaxContChosenEntry`
3. 已知的全局最大 Chosen 进度：`MaxChosenEntry`

只有 `CommittedEntry` < `MaxContChosenEntry` == `MaxChosenEntry` 时，DB 才可以直接通过读取 PLog 的方式来追赶到本地最新的进度，其他情况均需要进行先进行 Recover。来继续看看这里的 Recover 怎么实现的。

```c++
int clsCertainWrapper::SyncWaitCmd(clsClientCmd *poCmd) {
  uint64_t iEntityID = poCmd->GetEntityID();
  uint64_t iEntry = poCmd->GetEntry();

  uint32_t iPipeIdx;
  // 获取一个空的通知管道
  int iRet = m_poPipeMng->GetIdlePipeIdx(iPipeIdx, iEntityID);
  if (iRet != 0) {
    CertainLogError("E(%lu, %lu) GetIdlePipeIdx ret %d", iEntityID, iEntry, iRet);
    return iRet;
  }

  poCmd->SetPipeIdx(iPipeIdx);

  // 分配 IOWorker
  uint32_t iIOWorkerID = Hash(iEntityID) % m_poConf->GetIOWorkerNum();
  poCmd->SetIOTracker(IOTracker_t(0, 0, iIOWorkerID));

  uint32_t iEntityWorkerID = Hash(iEntityID) % m_poConf->GetEntityWorkerNum();
  clsIOReqQueue *poIOReqQueue = m_poQueueMng->GetIOReqQueue(iEntityWorkerID);

  // 将 Cmd 推入对应的 IO 队列中
  iRet = poIOReqQueue->PushByMultiThread(poCmd);
  if (iRet != 0) {
    m_poPipeMng->PutIdlePipeIdx(iPipeIdx);
    CertainLogError("PushByMultiThread ret %d", iRet);
    return eRetCodeQueueFailed;
  }

  uintptr_t iCheck = (uintptr_t)poCmd;

  CertainLogDebug("iPipeIdx %u iPtr %lu E(%lu, %lu) iUUID %lu", iPipeIdx, iCheck, iEntityID, iEntry,
                  poCmd->GetUUID());

  bool bOneMoreTry = false;
  // 等待管道通知（Cmd 完成后管道另一段有写入，这边读取就完成了等待）
  iRet = m_poPipeMng->SyncWaitByPipeIdx(iPipeIdx, iCheck);
  if (iRet == eRetCodePipePtrErr) {
    bOneMoreTry = true;
    // Try one more time, prev timeout ptr may come first.
    // There's probably some BUG in certain.
    iRet = m_poPipeMng->SyncWaitByPipeIdx(iPipeIdx, iCheck);
  }

  if (iRet != 0) {
    CertainLogFatal("BUG probably ibOneMoreTry %u ret %d cmd: %s", bOneMoreTry, iRet,
                    poCmd->GetTextCmd().c_str());
    m_poPipeMng->PutIdlePipeIdx(iPipeIdx);
    return eRetCodePipeWaitFailed;
  }

  // 回收通知管道
  m_poPipeMng->PutIdlePipeIdx(iPipeIdx);

  return poCmd->GetResult();
}
```

塞入 IO 队列中的 Recover Cmd 会在 `EntityWorker` 中被处理掉，这里的调用关系非常复杂：

```c++
void clsEntityWorker::Run() {
  while (1) {
    ...
    // 2.Do with IO request.
    poCmd = NULL;
    iRet = m_poIOReqQueue->TakeByOneThread(&poCmd);
    if (iRet == 0) {
      Assert(poCmd != NULL);
      bHasWork = true;

      iRet = DoWithIOReq(poCmd);
      if (iRet < 0) {
        CertainLogError("DoWithIOReq ret %d cmd %s", iRet, poCmd->GetTextCmd().c_str());
      }

      if (iRet != eRetCodePtrReuse) {
        delete poCmd, poCmd = NULL;
      }
    }
    ...
  }
}

int clsEntityWorker::DoWithIOReq(clsCmdBase *poCmd) {
  if (clsCertainWrapper::GetInstance()->GetConf()->GetEnableLearnOnly()) {
    if (poCmd->GetCmdID() != kPaxosCmd) {
      clsClientCmd *poClientCmd = dynamic_cast<clsClientCmd *>(poCmd);
      AssertNotEqual(poCmd, NULL);
      InvalidClientCmd(poClientCmd, eRetCodeRejectAll);
      return eRetCodePtrReuse;
    } else {
      return eRetCodeRejectAll;
    }
  }

  uint64_t iEntityID = poCmd->GetEntityID();
  AssertEqual(Hash(iEntityID) % m_poConf->GetEntityWorkerNum(), m_iWorkerID);
  CertainLogInfo("cmd: %s", poCmd->GetTextCmd().c_str());

  clsPaxosCmd *poPaxosCmd = NULL;
  clsClientCmd *poClientCmd = NULL;
  clsRecoverCmd *poRecoverCmd = NULL;

  switch (poCmd->GetCmdID()) {
    case kWriteBatchCmd:
      poClientCmd = dynamic_cast<clsClientCmd *>(poCmd);
      return DoWithClientCmd(poClientCmd);

    case kRecoverCmd:
      poRecoverCmd = dynamic_cast<clsRecoverCmd *>(poCmd);
      return DoWithRecoverCmd(poRecoverCmd);

    case kPaxosCmd:
      poPaxosCmd = dynamic_cast<clsPaxosCmd *>(poCmd);
      return DoWithPaxosCmd(poPaxosCmd);

    default:
      CertainLogError("cmd: %s", poCmd->GetTextCmd().c_str());
      Assert(false);
  }

  return 0;
}

int clsEntityWorker::DoWithRecoverCmd(clsRecoverCmd *poCmd) {
  uint64_t iEntityID = poCmd->GetEntityID();
  uint64_t iMaxCommitedEntry = poCmd->GetMaxCommitedEntry();
  CertainLogInfo("cmd: %s", poCmd->GetTextCmd().c_str());

  // 这里 Entry = 0 有特殊作用，下文会解释
  EntryInfo_t *ptInfo = m_poEntryMng->FindEntryInfo(iEntityID, 0);
  AssertEqual(ptInfo, NULL);

  EntityInfo_t *ptEntityInfo = m_poEntityMng->FindEntityInfo(iEntityID);
  if (ptEntityInfo != NULL) {
    // 内存中有对应的 EntityInfo
    CertainLogError("Failover E(%lu, %lu) Entrys: %lu %lu %lu ref %d %u", iEntityID,
                    iMaxCommitedEntry, ptEntityInfo->iMaxContChosenEntry,
                    ptEntityInfo->iMaxChosenEntry, ptEntityInfo->iMaxPLogEntry,
                    ptEntityInfo->iRefCount, ptEntityInfo->bRangeLoading);

    if (poCmd->IsEvictEntity()) {...}

    Assert(m_poEntityMng->Refresh(ptEntityInfo));

    if (poCmd->IsCheckGetAll()) {...}

    // 触发 DB 的 CatchUp
    CheckForCatchUp(ptEntityInfo, INVALID_ACCEPTOR_ID, 0);
    CheckIfNeedNotifyDB(ptEntityInfo);

    poCmd->SetMaxChosenEntry(uint64_t(ptEntityInfo->iMaxChosenEntry));
    poCmd->SetMaxContChosenEntry(uint64_t(ptEntityInfo->iMaxContChosenEntry));

    AssertEqual(ptEntityInfo->poClientCmd, NULL);
    if (ptEntityInfo->iMaxContChosenEntry < ptEntityInfo->iMaxChosenEntry) {
      InvalidClientCmd(poCmd, eRetCodeCatchUp);
      return eRetCodePtrReuse;
    } else if (ptEntityInfo->iMaxPLogEntry == INVALID_ENTRY) {
      CheckIfWaitRecoverCmd(ptEntityInfo, poCmd);
      return eRetCodePtrReuse;
    }

    InvalidClientCmd(poCmd, eRetCodeOK);
  } else {
    // 内存中没有对应的 EntityInfo
    if (poCmd->IsEvictEntity()) {...}

    if (!m_poEntityMng->CheckAndEliminate()) {...}

    // 创建一个
    ptEntityInfo = m_poEntityMng->CreateEntityInfo(iEntityID);
    if (ptEntityInfo == NULL) {
      CertainLogFatal("CreateEntityInfo failed cmd: %s", poCmd->GetTextCmd().c_str());
      InvalidClientCmd(poCmd, eRetCodeRouteErr);
      return eRetCodePtrReuse;
    }

    // 检查是否进行 CatchUp
    CheckForCatchUp(ptEntityInfo, INVALID_ACCEPTOR_ID, 0);

    CheckIfWaitRecoverCmd(ptEntityInfo, poCmd);
    return eRetCodePtrReuse;
  }

  return eRetCodePtrReuse;
}

bool clsEntityWorker::InvalidClientCmd(clsClientCmd *poCmd, int iResult) {
  if (poCmd == NULL) {
    return false;
  }

  // 设定 Result
  poCmd->SetResult(iResult);

  if (iResult != eRetCodeOK) {
    CertainLogError("InvalidClientCmd cmd %u uuid %lu result: %d", poCmd->GetCmdID(),
                    poCmd->GetUUID(), iResult);
  }

  // 使用 IO Worker 通知 Cmd 完成
  int iRet = m_poIOWorkerRouter->Go(poCmd);
  if (iRet != 0) {
    CertainLogError("BUG probably Go ret %d poCmd: %s", iRet, poCmd->GetTextCmd().c_str());

    // sum of list size <= MAX_ASYNC_PIPE_NUM
    m_poWaitingGoList.push_back(poCmd);
    return false;
  }

  return true;
}

// 如果不是 bRangeLoading 状态，直接报错 eRetCodeQueueFull
// 否则新建 Entry(0)，并加到 Timeout 队列里
void clsEntityWorker::CheckIfWaitRecoverCmd(EntityInfo_t *ptEntityInfo, clsRecoverCmd *poCmd) {
  // If the cmd is most likely timeout eventually, do fast failover.
  if (!ptEntityInfo->bRangeLoading) {
    // It should range load from plog, but failed as queue full.
    InvalidClientCmd(poCmd, eRetCodeQueueFull);
  } else {
    ptEntityInfo->poClientCmd = poCmd;
    // 再次出现 Entry(0)，用来对应 RecoverCmd
    EntryInfo_t *ptInfo = m_poEntryMng->CreateEntryInfo(ptEntityInfo, 0);
    m_poEntryMng->AddTimeout(ptInfo, m_poConf->GetRecoverTimeoutMS());
  }
}

// NotifyedEntry < MaxContChosenEntry，发通知给 DBWorker 做 CatchUp
void clsEntityWorker::CheckIfNeedNotifyDB(EntityInfo_t *ptEntityInfo) {
  if (ptEntityInfo->iNotifyedEntry < ptEntityInfo->iMaxContChosenEntry) {
    int iRet = clsDBWorker::NotifyDBWorker(ptEntityInfo->iEntityID);
    if (iRet != 0) {
      CertainLogError("NotifyDBWorker iEntityID %lu ret %d", ptEntityInfo->iEntityID, iRet);
    } else {
      ptEntityInfo->iNotifyedEntry = ptEntityInfo->iMaxContChosenEntry;
    }
  }
}
```

`DoWithRecoverCmd` 这里看着会有点懵了，是正常现象。`CheckForCatchUp` 的连带逻辑非常复杂，下一节详述。

### 2. CheckForCatchUp

### 3. RangeLoadFromPLog

### 4. 总结

