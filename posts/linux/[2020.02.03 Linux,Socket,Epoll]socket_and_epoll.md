# Linux Socket é€šä¿¡ä¸ IO å¤šè·¯å¤ç”¨

æœ€è¿‘åœ¨è¿›è¡Œ Linux ç³»ç»Ÿä¸‹ Socket ä¸ RPC ç›¸å…³çš„å·¥ä½œï¼Œæ•…ç³»ç»ŸåŒ–å­¦ä¹ ä¸€ä¸‹ Socket æ–¹é¢çš„çŸ¥è¯†ã€‚ä¸»è¦å‚è€ƒæ–‡çŒ®ä¸º ã€Š[The Linux Programming Interface](http://man7.org/tlpi/)ã€‹ï¼Œä¸­æ–‡ç‰ˆä¸ºã€Š[Linux/UNIX ç³»ç»Ÿç¼–ç¨‹æ‰‹å†Œ](https://www.epubit.com/bookDetails?id=N6862)ã€‹ï¼Œå¯ä»¥åœ¨çº¿è´­ä¹°ç”µå­ç‰ˆã€‚æœ¬æ–‡é‡ç‚¹ä»‹ç» *Internet domain stream socket*ï¼Œä¹Ÿå°±æ˜¯ *TCP socket*ã€‚

### 1. TCP Socket é€šä¿¡

TCP Socket é€šä¿¡æ—¶çš„ç³»ç»Ÿè°ƒç”¨æµç¨‹å¦‚ä¸‹å›¾æ‰€ç¤ºã€‚é¦–å…ˆ Server å’Œ Client å‡é€šè¿‡ `socket` åˆ›å»º Socket å¹¶è·å¾—å¯¹åº”çš„æ–‡ä»¶æè¿°ç¬¦ `sockfd`ï¼›è€Œå Server ä¾§éœ€ç»‘å®š `bind` ä¸€ä¸ªä¼—æ‰€å‘¨çŸ¥çš„åœ°å€ï¼Œå¹¶ä½¿ç”¨ `listen` å°† `sockfd` æ ‡è®°ä¸º *Passive* çŠ¶æ€ï¼Œæœ€åé€šè¿‡ `accept` æ¥å— Client çš„ `connect` è¿æ¥è¯·æ±‚ã€‚Server ä¾§ `accept` æˆåŠŸåä¼šè¿”å›ä¸€ä¸ªæ–°çš„æ–‡ä»¶æè¿°ç¬¦ `fd`ï¼Œå¯¹è¯¥æ–‡ä»¶æè¿°ç¬¦è¿›è¡Œè¯»å†™å¯ä»¥å®Œæˆ Server å’Œ Client çš„é€šä¿¡ã€‚

![TCP Socket é€šä¿¡ç³»ç»Ÿè°ƒç”¨ from "The Linux Programming Interface"](../images/57146ab1ee3c1cdedc5ea738f4ebfea7.svg)

Unix ä¸‹ä¸€åˆ‡çš†æ–‡ä»¶ï¼ˆEverything is a fileï¼‰ï¼Œå¯¹ Socket æ–‡ä»¶æè¿°ç¬¦ `fd` çš„æ“ä½œä¸ä¸€èˆ¬æ–‡ä»¶æ“ä½œæ— å¼‚ï¼Œå¸¸ç”¨ç³»ç»Ÿè°ƒç”¨ `read` / `write` / `close` / `fcntl` å‡æ­£å¸¸ä½¿ç”¨ã€‚Socket ç›¸å…³çš„å‡½æ•°å£°æ˜äº `sys/socket.h` ä¸­ï¼Œæœ‰è¯¦ç»†çš„æ³¨é‡Šï¼Œè¿™é‡Œæ‘˜å½•éƒ¨åˆ†ï¼š

```c++
/* Create a new socket of type TYPE in domain DOMAIN, using
   protocol PROTOCOL.  If PROTOCOL is zero, one is chosen automatically.
   Returns a file descriptor for the new socket, or -1 for errors.  */
extern int socket (int __domain, int __type, int __protocol) __THROW;

/* Give the socket FD the local address ADDR (which is LEN bytes long).  */
extern int bind (int __fd, __CONST_SOCKADDR_ARG __addr, socklen_t __len)

/* Open a connection on socket FD to peer at ADDR (which LEN bytes long).
   For connectionless socket types, just set the default address to send to
   and the only address from which to accept transmissions.
   Return 0 on success, -1 for errors.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int connect (int __fd, __CONST_SOCKADDR_ARG __addr, socklen_t __len);

/* Prepare to accept connections on socket FD.
   N connection requests will be queued before further requests are refused.
   Returns 0 on success, -1 for errors.  */
extern int listen (int __fd, int __n) __THROW;

/* Await a connection on socket FD.
   When a connection arrives, open a new socket to communicate with it,
   set *ADDR (which is *ADDR_LEN bytes long) to the address of the connecting
   peer and *ADDR_LEN to the address's actual length, and return the
   new socket's descriptor, or -1 for errors.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int accept (int __fd, __SOCKADDR_ARG __addr,
		   socklen_t *__restrict __addr_len);
```

ç®€å• Socket é€šä¿¡ä¸¾ä¾‹ï¼ˆ[åœ¨çº¿è¿è¡Œ](https://paiza.io/projects/CwP7rJLhNe4EuGXb0a6jpg?language=cpp)ï¼‰ã€‚è¿™é‡Œå¿½ç•¥äº†é”™è¯¯å¤„ç†éƒ¨åˆ†ï¼Œä»…å±•ç¤ºç³»ç»Ÿè°ƒç”¨æµç¨‹ï¼š

```c++
#include <arpa/inet.h>
#include <string.h>
#include <sys/socket.h>
#include <unistd.h>

#include <chrono>
#include <string>
#include <thread>

#define ZERO_OR_RETURN(expr)                             \
  do {                                                   \
    int ret = (expr);                                    \
    if (ret != 0) {                                      \
      printf("ERR: line %d return %d\n", __LINE__, ret); \
      return ret;                                        \
    }                                                    \
  } while (0);

int Server(int port) {
  struct sockaddr_in server_addr;
  memset(&server_addr, 0, sizeof(server_addr));
  server_addr.sin_family = AF_INET;
  server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
  server_addr.sin_port = htons(port);
  socklen_t server_len = sizeof(server_addr);

  int sockfd = socket(AF_INET, SOCK_STREAM, 0);
  printf("SERVER: Create Socket [%d]\n", sockfd);

  ZERO_OR_RETURN(bind(sockfd, (struct sockaddr *)&server_addr, server_len));
  printf("SERVER: Bind [%d] on [%d] port\n", sockfd, port);

  ZERO_OR_RETURN(listen(sockfd, 36));
  printf("SERVER: Listen [%d]\n", sockfd);

  struct sockaddr_in client_addr;
  socklen_t client_len = sizeof(client_addr);
  int fd = accept(sockfd, (struct sockaddr *)&client_addr, &client_len);
  printf("SERVER: Accept [%d]\n", fd);

  std::string buffer(1024, '\0');
  int r = read(fd, &buffer[0], buffer.size());
  buffer.resize(r);
  printf("SERVER: Recv [%s]\n", buffer.c_str());

  int w = write(fd, &buffer[0], buffer.size());
  buffer.resize(w);
  printf("SERVER: Send [%s]\n", buffer.c_str());

  ZERO_OR_RETURN(close(fd));
  ZERO_OR_RETURN(close(sockfd));
  return 0;
}

int Client(int port) {
  std::this_thread::sleep_for(std::chrono::milliseconds(100));

  struct sockaddr_in client_addr;
  memset(&client_addr, 0, sizeof(client_addr));
  client_addr.sin_family = AF_INET;
  client_addr.sin_addr.s_addr = htonl(INADDR_ANY);
  client_addr.sin_port = htons(port);
  socklen_t client_len = sizeof(client_addr);

  int sockfd = socket(AF_INET, SOCK_STREAM, 0);
  printf("CLIENT: Create Socket [%d]\n", sockfd);

  ZERO_OR_RETURN(connect(sockfd, (struct sockaddr *)&client_addr, client_len));
  printf("CLIENT: Connect [%d] on [%d] port\n", sockfd, port);

  std::string buffer("Hello Socket");
  int w = write(sockfd, &buffer[0], buffer.size());
  buffer.resize(w);
  printf("CLIENT: Send [%s]\n", buffer.c_str());

  int r = read(sockfd, &buffer[0], buffer.size());
  buffer.resize(r);
  printf("CLIENT: Recv [%s]\n", buffer.c_str());

  ZERO_OR_RETURN(close(sockfd));
  return 0;
}

int main() {
  srand(time(0));
  int port = rand() % 10000 + 10000;
  std::thread server(Server, port);
  std::thread client(Client, port);
  client.join();
  server.join();
  return 0;
}

/*
SERVER: Create Socket [4]
SERVER: Bind [4] on [12650] port
SERVER: Listen [4]
CLIENT: Create Socket [6]
CLIENT: Connect [6] on [12650] port
SERVER: Accept [5]
CLIENT: Send [Hello Socket]
SERVER: Recv [Hello Socket]
SERVER: Send [Hello Socket]
CLIENT: Recv [Hello Socket]
*/
```

### 2. é˜»å¡ä¸ IO å¤šè·¯å¤ç”¨

ä¸€åˆ‡çš†æ–‡ä»¶ï¼Œå®é™…ä¸Šæ˜¯ä¸€åˆ‡çš†å­—èŠ‚æµï¼Œæœ¬è´¨ä¸Šæ˜¯å¯ä»¥è¿›è¡Œ IO æ“ä½œçš„å†…æ ¸å¯¹è±¡ã€‚æ—¢ç„¶æ˜¯æµï¼Œå°±ä¼šæœ‰è¯»åˆ°ç©ºæˆ–è€…å†™åˆ°æ»¡çš„çŠ¶æ€ï¼Œå³ `read buffer` ä¸ºç©ºæˆ– `write buffer` å·²æ»¡ã€‚

![TCP Socket é€šä¿¡ç¼“å­˜æ¨¡å‹](../images/75c22dd97ad9905403a1f494d68ea392.svg)

è¿™æ—¶æœ‰ä¸¤ç§ç­‰å¾…æ–¹å¼å¯ä»¥é€‰æ‹©ï¼š

1. é˜»å¡ï¼šåœ¨è°ƒç”¨å¤„ç¡è§‰ï¼Œå½“ buffer å¯ç”¨æ—¶å†…æ ¸ä¼šå«é†’ä½ å¹¶è¿”å›ï¼Œä½†ç¡è§‰æ—¶æ²¡æ³•åšåˆ«çš„äº‹æƒ…ï¼›
2. éé˜»å¡ï¼šè°ƒç”¨ä¼šç«‹å³è¿”å›ï¼Œè¿™æ—¶å¯ä»¥åšåˆ«çš„äº‹æƒ…ï¼Œä½†å¹¶ä¸çŸ¥é“ä½•æ—¶ buffer å¯ç”¨ï¼Œéœ€è¦è‡ªè¡Œå®šæœŸæ£€æŸ¥ï¼ˆè½®è¯¢ï¼‰ã€‚

å½“åªæœ‰ä¸€ä¸ªæµéœ€è¦å¤„ç†æ—¶ï¼Œé˜»å¡ç­‰å¾…æ˜¯å¯è¡Œçš„ã€‚ä½†ç°å®æƒ…å†µé€šå¸¸æ˜¯éœ€è¦å¤„ç†å¤šä¸ªæµï¼Œè¿™æ—¶å¦‚æœç»§ç»­ä½¿ç”¨é˜»å¡ç­‰å¾…ï¼Œä¸€ä¸ªæµå°†ä¼šé˜»å¡å…¶ä»–æ‰€æœ‰æµçš„å¤„ç†ã€‚è¿™æ—¶ä¸€ä¸ªå¯è¡Œçš„æ–¹æ¡ˆæ˜¯ä½¿ç”¨å¤šçº¿ç¨‹/å¤šè¿›ç¨‹ï¼Œä¸€ä¸ªæµçš„é˜»å¡ä¸å½±å“å…¶ä»–æµçš„å¤„ç†ã€‚å¦ä¸€ä¸ªå¯è¡Œçš„æ–¹æ¡ˆæ˜¯å°†æ‰€æœ‰éœ€è¦ç­‰å¾…çš„æµå­˜åœ¨åˆ—è¡¨é‡Œï¼Œä½¿ç”¨éé˜»å¡æ¨¡å¼ï¼Œè½®è¯¢ï¼Œå¯¹å¯ç”¨çš„æµè¿›è¡Œç›¸åº”çš„å¤„ç†ã€‚

ä¸ºäº†æ›´æ¸…æ¥šåœ°æè¿°è¿™å‡ ç§ç­‰å¾…æ–¹å¼ï¼Œè¿™é‡Œå¼•ç”¨[çŸ¥ä¹ä¸ŠæŸ´å°å–µçš„ä¸€ä¸ªå›ç­”](https://www.zhihu.com/question/28594409/answer/52835876)å¹¶ç¨ä½œä¿®æ”¹ï¼š

> å‡è®¾ä½ æ˜¯ä¸€ä¸ªè€å¸ˆï¼Œè®© 30 ä¸ªå­¦ç”Ÿåšä½œä¸šï¼Œç„¶åæ‰¹æ”¹å­¦ç”Ÿçš„ä½œä¸šï¼Œä½ æœ‰ä¸‹é¢å‡ ä¸ªé€‰æ‹©ï¼š
>
> 1. **æŒ‰é¡ºåºé€ä¸ªæ£€æŸ¥å’Œæ‰¹æ”¹**ï¼Œå…ˆç­‰å¾… A å®Œæˆï¼Œæ‰¹æ”¹ A çš„ä½œä¸šï¼›ç„¶åæ˜¯ Bï¼Œä¹‹åæ˜¯ Cã€Dï¼Œä»¥æ­¤ç±»æ¨ã€‚è¿™ä¸­é—´å¦‚æœæœ‰ä¸€ä¸ªå­¦ç”Ÿåšå¾—æ…¢ï¼Œé‚£ä¹ˆå…¨ç­éƒ½ä¼šè¢«è€½è¯¯ï¼›
> 2. **åˆ›å»º 30 ä¸ªåˆ†èº«**ï¼Œæ¯ä¸ªåˆ†èº«ç­‰å¾…ä¸€ä¸ªå­¦ç”Ÿåšå®Œï¼Œå¹¶å¯¹å…¶ä½œä¸šæ‰¹æ”¹ï¼Œä¹Ÿå°±æ˜¯å¤šçº¿ç¨‹/å¤šè¿›ç¨‹æ¨¡å¼ï¼›
> 3. **ä¾æ¬¡æ£€æŸ¥å­¦ç”Ÿæ˜¯å¦å®Œæˆï¼Œæ‰¹æ”¹å·²ç»å®Œæˆçš„ä½œä¸š**ï¼Œå…ˆçœ‹ A æœ‰æ²¡æœ‰åšå®Œï¼Œåšå®Œçš„è¯å°±æ‰¹æ”¹ä»–çš„ï¼›æ²¡åšå®Œå°±ç»§ç»­çœ‹ B æœ‰æ²¡æœ‰åšå®Œï¼Œåšå®Œçš„è¯å°±æ‰¹æ”¹ä»–çš„ï¼›è¿™æ ·å°±ä¸ä¼šé—²ç€äº†ï¼Œåœ¨ç­é‡Œæ™ƒå‡ åœˆå°±å¯ä»¥ï¼Œä½†è€å¸ˆå§‹ç»ˆæ²¡æœ‰ä¼‘æ¯ï¼Œè¦ä¹ˆåœ¨æ£€æŸ¥è¦ä¹ˆåœ¨æ‰¹æ”¹ï¼Œå¯èƒ½æ£€æŸ¥äº† 20 ä¸ªæ‰ä¼šæ‰¹æ”¹ä¸€ä»½ï¼Œåšäº†å¾ˆå¤šæ— ç”¨åŠŸï¼›
> 4. **åœ¨è®²å°ä¼‘æ¯ï¼Œè®©å­¦ä¹ å§”å‘˜æŠŠå®Œæˆä½œä¸šçš„åŒå­¦åå­—è®°ä¸‹æ¥ï¼Œè€Œåæ‰¾å­¦ä¹ å§”å‘˜æ‹¿åå•ã€æ‰¹æ”¹åå•ä¸ŠåŒå­¦çš„ä½œä¸š**ï¼Œè¿™å°±æ˜¯ IO å¤šè·¯å¤ç”¨ã€‚

ç¬¬å››ç§å°±éœ€è¦å€ŸåŠ©äºç³»ç»Ÿè°ƒç”¨ `select` / `poll` / `epoll`ï¼Œæœ¬æ–‡ä»…ä»‹ç» `epoll`ã€‚`epoll` çš„æ ¸å¿ƒè°ƒç”¨å¦‚ä¸‹ï¼š

```c++
/* Creates an epoll instance.  Returns an fd for the new instance.
   The "size" parameter is a hint specifying the number of file
   descriptors to be associated with the new instance.  The fd
   returned by epoll_create() should be closed with close().  */
extern int epoll_create (int __size) __THROW;

/* Manipulate an epoll instance "epfd". Returns 0 in case of success,
   -1 in case of error ( the "errno" variable will contain the
   specific error code ) The "op" parameter is one of the EPOLL_CTL_*
   constants defined above. The "fd" parameter is the target of the
   operation. The "event" parameter describes which events the caller
   is interested in and any associated user data.  */
extern int epoll_ctl (int __epfd, int __op, int __fd,
		      struct epoll_event *__event) __THROW;

/* Wait for events on an epoll instance "epfd". Returns the number of
   triggered events returned in "events" buffer. Or -1 in case of
   error with the "errno" variable set to the specific error code. The
   "events" parameter is a buffer that will contain triggered
   events. The "maxevents" is the maximum number of events to be
   returned ( usually size of "events" ). The "timeout" parameter
   specifies the maximum wait time in milliseconds (-1 == infinite).

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int epoll_wait (int __epfd, struct epoll_event *__events,
		       int __maxevents, int __timeout);
```

`epoll_create` åˆ›å»ºå­¦ä¹ å§”å‘˜ï¼›`epoll_ctl` åˆ™æ˜¯æ³¨å†Œç­é‡Œçš„åŒå­¦ï¼Œå­¦å§”å°±çŸ¥é“è¦è®°å½•å“ªäº›åŒå­¦ä¸¾æ‰‹äº†ï¼›æœ€å `epoll_wait` åˆ™æ˜¯æ‰¾å­¦å§”æ‹¿åå•ã€‚æ‹¿åå•æ—¶å­¦å§”å¯èƒ½è¿˜æ²¡æœ‰å‘ç°åŒå­¦ä¸¾æ‰‹ï¼Œè¿™æ—¶å¯ä»¥é€‰æ‹©ä¸€ç›´ç­‰ç€å­¦å§”è®°ä¸‹ç¬¬ä¸€ä¸ªåå­—ï¼Œæˆ–è€…é™æ—¶ `timeout`ï¼Œåˆ°æ—¶é—´ä¹Ÿå¾—æŠŠç©ºåå•æ‹¿ä¸Šæ¥ã€‚

å­¦å§”è®°åå­—ä¹Ÿæ˜¯æœ‰æŠ€å·§çš„ï¼Œæœ‰ä¸¤ç§æ–¹å¼ï¼š

1. æ°´å¹³è§¦å‘ `Level Triggered`ï¼Œå­¦å§”è®©å®Œæˆä½œä¸šå¹¶ä¸”è¿˜æ²¡æœ‰è¢«æ‰¹æ”¹çš„åŒå­¦ä¸¾æ‰‹ï¼Œè€å¸ˆè¦åå•æ—¶å­¦å§”è‡ªå·±æŠŠä¸¾æ‰‹çš„åŒå­¦åå­—è®°ä¸‹æ¥ï¼Œè¿™æ˜¯ç›¸å¯¹å‹¤å¥‹çš„å­¦å§”ï¼›
2. è¾¹ç¼˜è§¦å‘ `Edge Triggered`ï¼Œå­¦å§”è®©åŒå­¦åšå®Œä½œä¸šæ—¶ï¼Œè‡ªå·±æŠŠåå­—å†™åˆ°åå•ä¸Šï¼Œè€å¸ˆæ‹¿åå•æ—¶å°±ç›´æ¥æŠŠåå•ä¸¢ç»™è€å¸ˆã€‚è¿™æ ·è‡ªå·±é—²ä¸€ç‚¹ï¼Œä½†æ˜¯å¦‚æœè€å¸ˆæ‹¿äº†åå•åå¿˜äº†æ‰¹æ”¹ï¼Œè¿™äº›åŒå­¦çš„ä½œä¸šå°±æ²¡æœ‰æœºä¼šè¢«æ‰¹æ”¹äº†ã€‚

### 3. Reactor æ¨¡å¼ä¸åç¨‹

ä½¿ç”¨åŸºäº `Epoll` çš„ Reactor æ¨¡å¼ï¼Œå¯ä»¥åœ¨å•çº¿ç¨‹ä¸‹â€œå¹¶å‘â€åœ°å¤„ç†å¤šä¸ªæµã€‚ä¸¾ä¸ªæ —å­ğŸŒ°ï¼š

```c++
#include <arpa/inet.h>
#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/epoll.h>
#include <unistd.h>

#define ZERO_OR_RETURN(expr)            \
  do {                                  \
    int ret = (expr);                   \
    if (ret != 0) {                     \
      printf("%d %d\n", __LINE__, ret); \
      return ret;                       \
    }                                   \
  } while (0);

int main(int argc, char *argv[]) {
  struct sockaddr_in serv_addr;
  socklen_t serv_len = sizeof(serv_addr);
  int port = atoi(argv[1]);

  int lfd = socket(AF_INET, SOCK_STREAM, 0);
  memset(&serv_addr, 0, sizeof(serv_addr));
  serv_addr.sin_family = AF_INET;
  serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);
  serv_addr.sin_port = htons(port);
  ZERO_OR_RETURN(bind(lfd, (struct sockaddr *)&serv_addr, serv_len));
  ZERO_OR_RETURN(listen(lfd, 36));

  struct sockaddr_in client_addr;
  socklen_t cli_len = sizeof(client_addr);

  int epfd = epoll_create(1024);
  struct epoll_event ev;
  ev.events = EPOLLIN;
  ev.data.fd = lfd;
  epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &ev);

  struct epoll_event all[1024];
  while (1) {
    int ret = epoll_wait(epfd, all, sizeof(all) / sizeof(all[0]), -1);
    for (int i = 0; i < ret; ++i) {
      int fd = all[i].data.fd;
      if (fd == lfd) {
        int cfd = accept(lfd, (struct sockaddr *)&client_addr, &cli_len);
        if (cfd == -1) {
          perror("> Accept Error");
          exit(1);
        }
        int flag = fcntl(cfd, F_GETFL);
        flag |= O_NONBLOCK;
        fcntl(cfd, F_SETFL, flag);
        struct epoll_event temp;
        temp.events = EPOLLIN | EPOLLET;
        temp.data.fd = cfd;
        epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &temp);
        char ip[64] = {0};
        printf("> New Client [%s:%d] => [%d]\n",
               inet_ntop(AF_INET, &client_addr.sin_addr.s_addr, ip, sizeof(ip)),
               ntohs(client_addr.sin_port), cfd);
      } else {
        if (!(all[i].events & EPOLLIN)) {
          continue;
        }
        char buffer[5] = {0};
        int len;
        while ((len = read(fd, buffer, sizeof(buffer))) > 0) {
          write(fd, buffer, len);
        }
        if (len == -1) {
          if (errno == EAGAIN) {
            // Buffer Data is Finished!;
          } else {
            perror("> Recv Error");
            exit(1);
          }
        }
        if (len == 0) {
          printf("> Client [%d] Disconnected!\n", fd);
          epoll_ctl(epfd, EPOLL_CTL_DEL, fd, NULL);
          close(fd);
        }
      }
    }
  }

  close(lfd);
  return 0;
}
```

ä¸Šæ–¹æ˜¯ Server ç«¯çš„ä»£ç ï¼Œå¯ä»¥ä½¿ç”¨ `netcat` è¿›è¡Œæµ‹è¯•ï¼Œæˆ–è€…ä½¿ç”¨ä¸‹æ–¹çš„ Client ä»£ç æµ‹è¯•ï¼š

```c++
#include <arpa/inet.h>
#include <signal.h>
#include <string.h>
#include <unistd.h>

#include <atomic>
#include <chrono>
#include <string>
#include <thread>

#define ZERO_OR_RETURN(expr)            \
  do {                                  \
    int ret = (expr);                   \
    if (ret != 0) {                     \
      printf("%d %d\n", __LINE__, ret); \
      return ret;                       \
    }                                   \
  } while (0);

std::atomic<bool> quit{false};
std::atomic<int> alive{0};

void do_quit(int) {
  quit = true;
  while (alive > 0) {
    std::this_thread::sleep_for(std::chrono::milliseconds(30));
  }
  exit(0);
}

int main(int argc, char *argv[]) {
  if (argc == 0) {
    printf("%s [port=8000] [thread=1] [data_size=100]");
    return 0;
  }
  signal(SIGINT, do_quit);

  int port = argc >= 2 ? std::atoi(argv[1]) : 8000;
  int thread = argc >= 3 ? std::atoi(argv[2]) : 1;
  int data_size = argc >= 4 ? std::atoi(argv[3]) : 100;
  std::string data(data_size, '\0');
  for (char &ch : data) {
    ch = rand() % 26 + 'A';
  }

  std::atomic<int> qps{0};
  for (int i = 0; i < thread; ++i) {
    std::thread([&] {
      ++alive;
      struct sockaddr_in cli_addr;
      socklen_t cli_len = sizeof(cli_addr);
      memset(&cli_addr, 0, sizeof(cli_addr));
      cli_addr.sin_family = AF_INET;
      cli_addr.sin_addr.s_addr = htonl(INADDR_ANY);
      cli_addr.sin_port = htons(port);
      std::string buffer(data);

      int sock = socket(AF_INET, SOCK_STREAM, 0);
      ZERO_OR_RETURN(connect(sock, (struct sockaddr *)&cli_addr, cli_len));
      while (!quit) {
        int writen = 0;
        while (writen < data.size()) {
          int w = write(sock, &data[writen], data.size() - writen);
          writen += w;
        }
        int readed = 0;
        while (readed < data.size()) {
          int r = read(sock, &buffer[readed], data.size() - readed);
          readed += r;
        }
        if (data == buffer) {
          qps += 1;
        }
      }

      ZERO_OR_RETURN(close(sock));
      --alive;
    }).detach();
  }

  while (true) {
    std::this_thread::sleep_for(std::chrono::seconds(1));
    printf("QPS: %d\n", qps.load());
    qps = 0;
  }
}
```

Reactor æ¨¡å¼çš„æ ¸å¿ƒæ€æƒ³æ˜¯å½“äº‹ä»¶å‘ç”Ÿæ—¶ï¼ˆæµå¯ç”¨ï¼‰ï¼Œæ¥é€šçŸ¥å¯¹è±¡å¤„ç†è¯¥äº‹ä»¶ï¼ˆIO æ“ä½œï¼‰ï¼Œå…¶ä»–æ—¶é—´åˆ™å¯ä»¥ä¼‘æ¯ã€‚è¿™ä¸åç¨‹çš„é£æ ¼æ˜¯è¿‘ä¼¼çš„ï¼Œä¸åŒçš„æ˜¯åç¨‹å†™å‡ºæ¥çš„ä»£ç å’ŒåŒæ­¥çš„ä»£ç é£æ ¼ä¸€è‡´ï¼Œå½“æµé˜»å¡æ—¶è‡ªåŠ¨æ”¾å¼ƒæ‰§è¡Œæƒ `Yield`ï¼Œå½“æµå¯ç”¨æ—¶å†æ¢å¤ `Resume`ã€‚å®é™…ä¸Šå¾ˆå¤šåç¨‹åº“çš„æ ¸å¿ƒå°±æ˜¯ `Epoll`ï¼Œä¾‹å¦‚å¾®ä¿¡å¼€æºçš„ [libco](https://github.com/Tencent/libco)ã€‚è¿™éƒ¨åˆ†å¾…ç¬”è€…å®Œå–„åç»§ç»­è¡¥å……ã€‚

### References

1. ["The Linux Programming Interface", *Michael Kerrisk*](http://man7.org/tlpi/)

