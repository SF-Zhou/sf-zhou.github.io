# LevelDB æºç åˆ†æã€Œä¸‰ã€é«˜æ€§èƒ½å†™æ“ä½œã€

æœ¬ç³»åˆ—çš„[å‰ä¸¤ç¯‡](/leveldb/leveldb_02_data_structure.html)ä»‹ç»äº† LevelDB ä¸­ä½¿ç”¨çš„æ•°æ®ç»“æ„ï¼Œå¹¶æ²¡æœ‰ç‰µæ¶‰åˆ° LevelDB çš„æ ¸å¿ƒå®ç°ã€‚æ¥ä¸‹æ¥çš„å‡ ç¯‡å°†ç€é‡ä»‹ç» LevelDB æ ¸å¿ƒç»„ä»¶ï¼ŒåŒ…æ‹¬æ—¥å¿—ã€å†…å­˜æ•°æ®åº“ã€SSTableã€å‹ç¼©å’Œç‰ˆæœ¬ç®¡ç†ã€‚æœ¬ç¯‡ç€é‡é˜è¿°é«˜æ€§èƒ½å†™æ“ä½œçš„ç§˜å¯†ï¼šæ—¥å¿—å’Œå†…å­˜æ•°æ®åº“ã€‚

æ€æ ·æœ€å¿«åœ°æŠŠé”®å€¼å¯¹å­˜èµ·æ¥ï¼Ÿä¸è€ƒè™‘æŸ¥æ‰¾çš„é€Ÿåº¦çš„è¯ï¼Œè¿½åŠ åœ°å†™å…¥æ–‡ä»¶æ˜¯æœ€å¿«çš„ï¼ŒæŸ¥æ‰¾æ—¶åå‘æŸ¥æ‰¾ã€‚ä¸¾ä¸ªä¾‹å­ğŸŒ°ï¼š

```python
dict[1] = "LY"
dict[2] = "SF"
dict[3] = "MX"
del dict[1]
dict[2] = "ST"
```

ä¸Šé¢ä»£ç ä¸­çš„ 5 ä¸ªæ“ä½œï¼Œé¡ºåºåœ°å†™å…¥æ–‡ä»¶ï¼Œæ¯æ¬¡æ·»åŠ ä¸€è¡Œï¼Œå¯ä»¥å¾—åˆ°ç±»ä¼¼å¦‚ä¸‹çš„è®°å½•ï¼š

```
Add 1: "LY"
Add 2: "SF"
Add 3: "MX"
Del 1
Add 2: "ST"
```

æŸ¥æ‰¾æ—¶åå‘æŸ¥æ‰¾ï¼Œä¾‹å¦‚æŸ¥æ‰¾ `key=2`ï¼Œè¿”å›æœ€åä¸€è¡Œæœ€æ–°çš„ç»“æœ "ST"ï¼›æŸ¥æ‰¾ `key=1`ï¼Œè¿”å›å€’æ•°ç¬¬äºŒè¡Œçš„åˆ é™¤æ“ä½œã€‚LevelDB ä¸­å†™æ“ä½œä½¿ç”¨äº†ç›¸ä¼¼çš„æŠ€æœ¯ï¼Œå…¶å†™å…¥åˆ†ä¸ºä¸¤æ­¥ï¼š

1. å°†æ•°æ®è¿½åŠ åˆ°æ—¥å¿—ä¸­ï¼›
2. å°†æ•°æ®æ’å…¥å†…å­˜æ•°æ®åº“ã€‚

è¿½åŠ åˆ°æ—¥å¿—ä¸€æ¥ä¿è¯äº†å†™å…¥é€Ÿåº¦ï¼ŒäºŒæ¥ä¿è¯äº†æ•°æ®ä¸ä¼šä¸¢å¤±ï¼Œåªè¦æ—¥å¿—å†™å…¥äº†ç£ç›˜ï¼Œå³ä½¿æœºå™¨æ–­ç”µäº†ï¼Œé‡å¯åä¹Ÿå¯ä»¥æ ¹æ®æ—¥å¿—æ¢å¤å‡ºæ•°æ®æ¥ï¼›æ’å…¥å†…å­˜æ•°æ®åº“åŒæ ·ç»´æŒç€é«˜æ€§èƒ½ï¼Œå½“å†…å­˜æ•°æ®åº“çš„å°å¤§åˆ°è¾¾ä¸€å®šè§„æ¨¡æ—¶ï¼Œä¼šå°†å½“å‰çš„å†…å­˜æ•°æ®åº“æŒä¹…åŒ–å¹¶å»ºç«‹æ–°çš„å†…å­˜æ•°æ®åº“ã€‚

### æ‰¹é‡å†™æ“ä½œ WriteBatch

LevelDB çš„é”®å€¼å¯¹å†™å…¥æ¥å£ä¸º `DB::Put(options, key, value)`ï¼Œåˆ é™¤æŸä¸ªé”®å€¼å¯¹çš„æ¥å£ä¸º `Delete(options, key)`ï¼Œå…¶å¯¹åº”çš„å®ç°ä¸ºï¼š

```c++
// source: db/db_impl.cc

Status DB::Put(const WriteOptions& opt, const Slice& key, const Slice& value) {
  WriteBatch batch;
  batch.Put(key, value);
  return Write(opt, &batch);
}

Status DB::Delete(const WriteOptions& opt, const Slice& key) {
  WriteBatch batch;
  batch.Delete(key);
  return Write(opt, &batch);
}
```

æ’å…¥å’Œåˆ é™¤æ“ä½œé¦–å…ˆè¢«æ‰“åŒ…æˆä¸€ä¸ª `WriteBatch`ã€‚å…¶å®šä¹‰äº [`include/leveldb/write_batch.h`](https://github.com/google/leveldb/blob/master/include/leveldb/write_batch.h)ï¼š

```c++
// WriteBatch holds a collection of updates to apply atomically to a DB.
//
// The updates are applied in the order in which they are added
// to the WriteBatch.  For example, the value of "key" will be "v3"
// after the following batch is written:
//
//    batch.Put("key", "v1");
//    batch.Delete("key");
//    batch.Put("key", "v2");
//    batch.Put("key", "v3");
//
// Multiple threads can invoke const methods on a WriteBatch without
// external synchronization, but if any of the threads may call a
// non-const method, all threads accessing the same WriteBatch must use
// external synchronization.

#include <string>

#include "leveldb/export.h"
#include "leveldb/status.h"

namespace leveldb {

class Slice;

class LEVELDB_EXPORT WriteBatch {
 public:
  class LEVELDB_EXPORT Handler {
   public:
    virtual ~Handler();
    virtual void Put(const Slice& key, const Slice& value) = 0;
    virtual void Delete(const Slice& key) = 0;
  };

  WriteBatch();

  // Intentionally copyable.
  WriteBatch(const WriteBatch&) = default;
  WriteBatch& operator=(const WriteBatch&) = default;

  ~WriteBatch();

  // Store the mapping "key->value" in the database.
  void Put(const Slice& key, const Slice& value);

  // If the database contains a mapping for "key", erase it.  Else do nothing.
  void Delete(const Slice& key);

  // Clear all updates buffered in this batch.
  void Clear();

  // The size of the database changes caused by this batch.
  //
  // This number is tied to implementation details, and may change across
  // releases. It is intended for LevelDB usage metrics.
  size_t ApproximateSize() const;

  // Copies the operations in "source" to this batch.
  //
  // This runs in O(source size) time. However, the constant factor is better
  // than calling Iterate() over the source batch with a Handler that replicates
  // the operations into this batch.
  void Append(const WriteBatch& source);

  // Support for iterating over the contents of a batch.
  Status Iterate(Handler* handler) const;

 private:
  friend class WriteBatchInternal;

  std::string rep_;  // See comment in write_batch.cc for the format of rep_
};

}  // namespace leveldb
```

`WriteBatch` æ¥å£ä¸­é™¤äº†æåˆ°çš„ `Put` å’Œ `Delete`ï¼Œè¿˜æä¾›äº†ä¸€ä¸ª `Append` æ–¹æ³•å¯ä»¥å°†å…¶ä»– `WriteBatch` åˆå¹¶è¿‡æ¥ã€‚å¦å¤–æä¾›äº†ä¸€ä¸ª `Iterate` è¿­ä»£å‡½æ•°å’Œå¯¹åº”çš„ `Handler` ç±»æ¥å£ï¼Œåé¢ä¼šä½¿ç”¨åˆ°ã€‚å€¼å¾—æ³¨æ„çš„è¿˜æœ‰ `friend class WriteBatchInternal;`ï¼Œè¿™ç§é¢„å…ˆå®šä¹‰ä¸€ä¸ªå‹ç±»ã€åæœŸåˆ™å¯ä»¥åœ¨è¯¥å‹ç±»ä¸­ç›´æ¥è®¿é—®ç§æœ‰å˜é‡å’Œæ–¹æ³•ï¼Œé€‚åˆä¸€äº›ä¸æ–¹ä¾¿æš´éœ²å‡ºæ¥çš„å†…éƒ¨æ“ä½œã€‚æ¥ç€çœ‹ `WriteBatchInternal` çš„å®šä¹‰ [`db/write_batch_internal.h`](https://github.com/google/leveldb/blob/master/db/write_batch_internal.h)ï¼š

```c++
#include "db/dbformat.h"
#include "leveldb/write_batch.h"

namespace leveldb {

class MemTable;

// WriteBatchInternal provides static methods for manipulating a
// WriteBatch that we don't want in the public WriteBatch interface.
class WriteBatchInternal {
 public:
  // Return the number of entries in the batch.
  static int Count(const WriteBatch* batch);

  // Set the count for the number of entries in the batch.
  static void SetCount(WriteBatch* batch, int n);

  // Return the sequence number for the start of this batch.
  static SequenceNumber Sequence(const WriteBatch* batch);

  // Store the specified number as the sequence number for the start of
  // this batch.
  static void SetSequence(WriteBatch* batch, SequenceNumber seq);

  static Slice Contents(const WriteBatch* batch) { return Slice(batch->rep_); }

  static size_t ByteSize(const WriteBatch* batch) { return batch->rep_.size(); }

  static void SetContents(WriteBatch* batch, const Slice& contents);

  static Status InsertInto(const WriteBatch* batch, MemTable* memtable);

  static void Append(WriteBatch* dst, const WriteBatch* src);
};

}  // namespace leveldb
```

ç±»ä¸­å…¨éƒ¨æ˜¯é™æ€å‡½æ•°ï¼Œå¹¶ä¸”é™„å¸¦è‡³å°‘ä¸€ä¸ª `WriteBatch* batch` å‚æ•°ã€‚å› ä¸ºå‹ç±»çš„åŸå› è¿™äº›å‡½æ•°é‡Œå‡å¯ä»¥è®¿é—® `WriteBatch` é‡Œå”¯ä¸€çš„ç§æœ‰æˆå‘˜ `rep_`ã€‚`WriteBatch` å’Œ `WriteBatchInternal` å‡½æ•°å®ç°å‡ä½äº [`db/write_batch.cc`](https://github.com/google/leveldb/blob/master/db/write_batch.cc)ï¼Œä¸ºäº†æ–¹ä¾¿é˜…è¯»æˆ‘ä¼šæŠŠå†…éƒ¨çš„å‡½æ•°é‡æ–°æ’åºï¼š

```c++
// WriteBatch header has an 8-byte sequence number followed by a 4-byte count.
static const size_t kHeader = 12;

WriteBatch::WriteBatch() { Clear(); }

WriteBatch::~WriteBatch() = default;

WriteBatch::Handler::~Handler() = default;

void WriteBatch::Clear() {
  rep_.clear();
  rep_.resize(kHeader);
}

size_t WriteBatch::ApproximateSize() const { return rep_.size(); }

int WriteBatchInternal::Count(const WriteBatch* b) {
  return DecodeFixed32(b->rep_.data() + 8);
}

void WriteBatchInternal::SetCount(WriteBatch* b, int n) {
  EncodeFixed32(&b->rep_[8], n);
}

SequenceNumber WriteBatchInternal::Sequence(const WriteBatch* b) {
  return SequenceNumber(DecodeFixed64(b->rep_.data()));
}

void WriteBatchInternal::SetSequence(WriteBatch* b, SequenceNumber seq) {
  EncodeFixed64(&b->rep_[0], seq);
}
```

`WriteBatch::rep_` çš„å‰ 12 ä¸ªå­—èŠ‚å®šä¹‰ä¸º `header`ï¼Œå­˜å‚¨äº† sequence number å’Œ countã€‚`EncodeFixed` å’Œ `DecodeFixed`ç³»åˆ—å‡½æ•°å®ç°äº†æ•°å€¼åˆ°å­—ç¬¦ä¸²çš„ç¼–è§£ç ï¼Œæœ‰å…´è¶£å¯ä»¥å‰å¾€ [`util/coding.cc`](https://github.com/google/leveldb/blob/master/util/coding.cc) æŸ¥çœ‹å®ç°ï¼Œè¿™é‡Œä¸è¯¦ç»†ä»‹ç»äº†ã€‚æ¥ä¸‹æ¥çœ‹ `Put` å’Œ `Delete` çš„å®ç°ï¼š

```c++
void WriteBatch::Put(const Slice& key, const Slice& value) {
  WriteBatchInternal::SetCount(this, WriteBatchInternal::Count(this) + 1);
  rep_.push_back(static_cast<char>(kTypeValue));
  PutLengthPrefixedSlice(&rep_, key);
  PutLengthPrefixedSlice(&rep_, value);
}

void WriteBatch::Delete(const Slice& key) {
  WriteBatchInternal::SetCount(this, WriteBatchInternal::Count(this) + 1);
  rep_.push_back(static_cast<char>(kTypeDeletion));
  PutLengthPrefixedSlice(&rep_, key);
}

void WriteBatch::Append(const WriteBatch& source) {
  WriteBatchInternal::Append(this, &source);
}

void WriteBatchInternal::SetContents(WriteBatch* b, const Slice& contents) {
  assert(contents.size() >= kHeader);
  b->rep_.assign(contents.data(), contents.size());
}

void WriteBatchInternal::Append(WriteBatch* dst, const WriteBatch* src) {
  SetCount(dst, Count(dst) + Count(src));
  assert(src->rep_.size() >= kHeader);
  dst->rep_.append(src->rep_.data() + kHeader, src->rep_.size() - kHeader);
}
```

`Put` å’Œ `Delete` é¦–å…ˆå°†è®¡æ•°åŠ ä¸€ï¼Œåœ¨ `rep_` ä¸­å†™å…¥æ“ä½œç±»å‹ï¼Œå†å†™å…¥é”®å€¼å¯¹ã€‚`PutLengthPrefixedSlice` å‡½æ•°ä¼šå…ˆå†™å…¥å­—ç¬¦ä¸²çš„é•¿åº¦ï¼Œå†å†™å…¥å­—ç¬¦ä¸²çš„å†…å®¹ã€‚`WriteBatchInternal` çš„èµ‹å€¼å’Œè¿½åŠ å‡æ˜¯å¯¹ `rep_` çš„è¿›è¡Œæ“ä½œã€‚ç»§ç»­çœ‹è¿­ä»£å™¨çš„éƒ¨åˆ†ï¼š

```c++
Status WriteBatch::Iterate(Handler* handler) const {
  Slice input(rep_);
  if (input.size() < kHeader) {
    return Status::Corruption("malformed WriteBatch (too small)");
  }

  input.remove_prefix(kHeader);
  Slice key, value;
  int found = 0;
  while (!input.empty()) {
    found++;
    char tag = input[0];
    input.remove_prefix(1);
    switch (tag) {
      case kTypeValue:
        if (GetLengthPrefixedSlice(&input, &key) &&
            GetLengthPrefixedSlice(&input, &value)) {
          handler->Put(key, value);
        } else {
          return Status::Corruption("bad WriteBatch Put");
        }
        break;
      case kTypeDeletion:
        if (GetLengthPrefixedSlice(&input, &key)) {
          handler->Delete(key);
        } else {
          return Status::Corruption("bad WriteBatch Delete");
        }
        break;
      default:
        return Status::Corruption("unknown WriteBatch tag");
    }
  }
  if (found != WriteBatchInternal::Count(this)) {
    return Status::Corruption("WriteBatch has wrong count");
  } else {
    return Status::OK();
  }
}

namespace {
class MemTableInserter : public WriteBatch::Handler {
 public:
  SequenceNumber sequence_;
  MemTable* mem_;

  void Put(const Slice& key, const Slice& value) override {
    mem_->Add(sequence_, kTypeValue, key, value);
    sequence_++;
  }
  void Delete(const Slice& key) override {
    mem_->Add(sequence_, kTypeDeletion, key, Slice());
    sequence_++;
  }
};
}  // namespace

Status WriteBatchInternal::InsertInto(const WriteBatch* b, MemTable* memtable) {
  MemTableInserter inserter;
  inserter.sequence_ = WriteBatchInternal::Sequence(b);
  inserter.mem_ = memtable;
  return b->Iterate(&inserter);
}
```

[ç»§ç»­å†™ä½œä¸­â€¦â€¦]

