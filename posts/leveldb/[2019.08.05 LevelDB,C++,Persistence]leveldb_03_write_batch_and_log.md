# LevelDB æºç åˆ†æã€Œä¸‰ã€é«˜æ€§èƒ½å†™æ“ä½œã€

æœ¬ç³»åˆ—çš„[å‰ä¸¤ç¯‡](/leveldb/leveldb_02_data_structure.html)ä»‹ç»äº† LevelDB ä¸­ä½¿ç”¨çš„æ•°æ®ç»“æ„ï¼Œå¹¶æ²¡æœ‰ç‰µæ¶‰åˆ° LevelDB çš„æ ¸å¿ƒå®ç°ã€‚æ¥ä¸‹æ¥çš„å‡ ç¯‡å°†ç€é‡ä»‹ç» LevelDB æ ¸å¿ƒç»„ä»¶ï¼ŒåŒ…æ‹¬æ—¥å¿—ã€å†…å­˜æ•°æ®åº“ã€SortedTableã€Compaction å’Œç‰ˆæœ¬ç®¡ç†ã€‚æœ¬ç¯‡ç€é‡é˜è¿°é«˜æ€§èƒ½å†™æ“ä½œçš„ç§˜å¯†ï¼šæ—¥å¿—å’Œå†…å­˜æ•°æ®åº“ã€‚

æ€æ ·æœ€å¿«åœ°æŠŠé”®å€¼å¯¹å­˜èµ·æ¥ï¼Ÿä¸è€ƒè™‘æŸ¥æ‰¾çš„é€Ÿåº¦çš„è¯ï¼Œè¿½åŠ åœ°å†™å…¥æ–‡ä»¶æ˜¯æœ€å¿«çš„ï¼ŒæŸ¥æ‰¾æ—¶åå‘æŸ¥æ‰¾ã€‚ä¸¾ä¸ªä¾‹å­ğŸŒ°ï¼š

```python
dict[1] = "LY"
dict[2] = "SF"
dict[3] = "MX"
del dict[1]
dict[2] = "ST"
```

ä¸Šé¢ä»£ç ä¸­çš„ 5 ä¸ªæ“ä½œï¼Œé¡ºåºåœ°å†™å…¥æ–‡ä»¶ï¼Œæ¯æ¬¡æ·»åŠ ä¸€è¡Œï¼Œå¯ä»¥å¾—åˆ°ç±»ä¼¼å¦‚ä¸‹çš„è®°å½•ï¼š

```
Add 1: "LY"
Add 2: "SF"
Add 3: "MX"
Del 1
Add 2: "ST"
```

æŸ¥æ‰¾æ—¶åå‘æŸ¥æ‰¾ï¼Œä¾‹å¦‚æŸ¥æ‰¾ `key=2`ï¼Œè¿”å›æœ€åä¸€è¡Œæœ€æ–°çš„ç»“æœ "ST"ï¼›æŸ¥æ‰¾ `key=1`ï¼Œè¿”å›å€’æ•°ç¬¬äºŒè¡Œçš„åˆ é™¤æ“ä½œã€‚LevelDB ä¸­å†™æ“ä½œä½¿ç”¨äº†ç›¸ä¼¼çš„æŠ€æœ¯ï¼Œå…¶å†™å…¥åˆ†ä¸ºä¸¤æ­¥ï¼š

1. å°†æ•°æ®è¿½åŠ åˆ°æ—¥å¿—ä¸­ï¼›
2. å°†æ•°æ®æ’å…¥å†…å­˜æ•°æ®åº“ã€‚

è¿½åŠ åˆ°æ—¥å¿—ä¸€æ¥ä¿è¯äº†å†™å…¥é€Ÿåº¦ï¼ŒäºŒæ¥ä¿è¯äº†æ•°æ®ä¸ä¼šä¸¢å¤±ï¼Œåªè¦æ—¥å¿—å†™å…¥äº†ç£ç›˜ï¼Œå³ä½¿æœºå™¨æ–­ç”µäº†ï¼Œé‡å¯åä¹Ÿå¯ä»¥æ ¹æ®æ—¥å¿—æ¢å¤å‡ºæ•°æ®æ¥ï¼›æ’å…¥å†…å­˜æ•°æ®åº“åŒæ ·ç»´æŒç€é«˜æ€§èƒ½ï¼Œå½“å†…å­˜æ•°æ®åº“çš„å°å¤§åˆ°è¾¾ä¸€å®šè§„æ¨¡æ—¶ï¼Œä¼šå°†å½“å‰çš„å†…å­˜æ•°æ®åº“æŒä¹…åŒ–å¹¶å»ºç«‹æ–°çš„å†…å­˜æ•°æ®åº“ã€‚

### 1. æ‰¹é‡å†™æ“ä½œ WriteBatch

LevelDB çš„é”®å€¼å¯¹å†™å…¥æ¥å£ä¸º `DB::Put(options, key, value)`ï¼Œåˆ é™¤æŸä¸ªé”®å€¼å¯¹çš„æ¥å£ä¸º `DB::Delete(options, key)`ï¼Œå…¶å¯¹åº”çš„å®ç°ä¸ºï¼š

```c++
// source: db/db_impl.cc

Status DB::Put(const WriteOptions& opt, const Slice& key, const Slice& value) {
  WriteBatch batch;
  batch.Put(key, value);
  return Write(opt, &batch);
}

Status DB::Delete(const WriteOptions& opt, const Slice& key) {
  WriteBatch batch;
  batch.Delete(key);
  return Write(opt, &batch);
}
```

æ’å…¥å’Œåˆ é™¤æ“ä½œé¦–å…ˆè¢«æ‰“åŒ…æˆä¸€ä¸ª `WriteBatch`ã€‚å…¶å®šä¹‰äº [`include/leveldb/write_batch.h`](https://github.com/google/leveldb/blob/master/include/leveldb/write_batch.h)ï¼š

```c++
// WriteBatch holds a collection of updates to apply atomically to a DB.
//
// The updates are applied in the order in which they are added
// to the WriteBatch.  For example, the value of "key" will be "v3"
// after the following batch is written:
//
//    batch.Put("key", "v1");
//    batch.Delete("key");
//    batch.Put("key", "v2");
//    batch.Put("key", "v3");
//
// Multiple threads can invoke const methods on a WriteBatch without
// external synchronization, but if any of the threads may call a
// non-const method, all threads accessing the same WriteBatch must use
// external synchronization.

#include <string>

#include "leveldb/export.h"
#include "leveldb/status.h"

namespace leveldb {

class Slice;

class LEVELDB_EXPORT WriteBatch {
 public:
  class LEVELDB_EXPORT Handler {
   public:
    virtual ~Handler();
    virtual void Put(const Slice& key, const Slice& value) = 0;
    virtual void Delete(const Slice& key) = 0;
  };

  WriteBatch();

  // Intentionally copyable.
  WriteBatch(const WriteBatch&) = default;
  WriteBatch& operator=(const WriteBatch&) = default;

  ~WriteBatch();

  // Store the mapping "key->value" in the database.
  void Put(const Slice& key, const Slice& value);

  // If the database contains a mapping for "key", erase it.  Else do nothing.
  void Delete(const Slice& key);

  // Clear all updates buffered in this batch.
  void Clear();

  // The size of the database changes caused by this batch.
  //
  // This number is tied to implementation details, and may change across
  // releases. It is intended for LevelDB usage metrics.
  size_t ApproximateSize() const;

  // Copies the operations in "source" to this batch.
  //
  // This runs in O(source size) time. However, the constant factor is better
  // than calling Iterate() over the source batch with a Handler that replicates
  // the operations into this batch.
  void Append(const WriteBatch& source);

  // Support for iterating over the contents of a batch.
  Status Iterate(Handler* handler) const;

 private:
  friend class WriteBatchInternal;

  std::string rep_;  // See comment in write_batch.cc for the format of rep_
};

}  // namespace leveldb
```

`WriteBatch` æ¥å£ä¸­é™¤äº†æåˆ°çš„ `Put` å’Œ `Delete`ï¼Œè¿˜æä¾›äº†ä¸€ä¸ª `Append` æ–¹æ³•å¯ä»¥å°†å…¶ä»– `WriteBatch` åˆå¹¶è¿‡æ¥ã€‚å¦å¤–æä¾›äº†ä¸€ä¸ª `Iterate` è¿­ä»£å‡½æ•°å’Œå¯¹åº”çš„ `Handler` ç±»æ¥å£ï¼Œåé¢ä¼šä½¿ç”¨åˆ°ã€‚å€¼å¾—æ³¨æ„çš„è¿˜æœ‰ `friend class WriteBatchInternal;`ï¼Œè¿™ç§é¢„å…ˆå®šä¹‰ä¸€ä¸ªå‹å…ƒç±»ã€åæœŸåˆ™å¯ä»¥åœ¨è¯¥å‹å…ƒç±»ä¸­ç›´æ¥è®¿é—®ç§æœ‰å˜é‡å’Œæ–¹æ³•ï¼Œé€‚åˆä¸€äº›ä¸æ–¹ä¾¿æš´éœ²å‡ºæ¥çš„å†…éƒ¨æ“ä½œã€‚æ¥ç€çœ‹ `WriteBatchInternal` çš„å®šä¹‰ [`db/write_batch_internal.h`](https://github.com/google/leveldb/blob/master/db/write_batch_internal.h)ï¼š

```c++
#include "db/dbformat.h"
#include "leveldb/write_batch.h"

namespace leveldb {

class MemTable;

// WriteBatchInternal provides static methods for manipulating a
// WriteBatch that we don't want in the public WriteBatch interface.
class WriteBatchInternal {
 public:
  // Return the number of entries in the batch.
  static int Count(const WriteBatch* batch);

  // Set the count for the number of entries in the batch.
  static void SetCount(WriteBatch* batch, int n);

  // Return the sequence number for the start of this batch.
  static SequenceNumber Sequence(const WriteBatch* batch);

  // Store the specified number as the sequence number for the start of
  // this batch.
  static void SetSequence(WriteBatch* batch, SequenceNumber seq);

  static Slice Contents(const WriteBatch* batch) { return Slice(batch->rep_); }

  static size_t ByteSize(const WriteBatch* batch) { return batch->rep_.size(); }

  static void SetContents(WriteBatch* batch, const Slice& contents);

  static Status InsertInto(const WriteBatch* batch, MemTable* memtable);

  static void Append(WriteBatch* dst, const WriteBatch* src);
};

}  // namespace leveldb
```

ç±»ä¸­å…¨éƒ¨æ˜¯é™æ€å‡½æ•°ï¼Œå¹¶ä¸”é™„å¸¦è‡³å°‘ä¸€ä¸ª `WriteBatch* batch` å‚æ•°ã€‚å› ä¸ºå‹å…ƒç±»çš„åŸå› è¿™äº›å‡½æ•°é‡Œå‡å¯ä»¥è®¿é—® `WriteBatch` é‡Œå”¯ä¸€çš„ç§æœ‰æˆå‘˜ `rep_`ã€‚`WriteBatch` å’Œ `WriteBatchInternal` å‡½æ•°å®ç°å‡ä½äº [`db/write_batch.cc`](https://github.com/google/leveldb/blob/master/db/write_batch.cc)ï¼Œä¸ºäº†æ–¹ä¾¿é˜…è¯»æˆ‘ä¼šæŠŠå†…éƒ¨çš„å‡½æ•°é‡æ–°æ’åºï¼š

```c++
// WriteBatch header has an 8-byte sequence number followed by a 4-byte count.
static const size_t kHeader = 12;

WriteBatch::WriteBatch() { Clear(); }

WriteBatch::~WriteBatch() = default;

WriteBatch::Handler::~Handler() = default;

void WriteBatch::Clear() {
  rep_.clear();
  rep_.resize(kHeader);
}

size_t WriteBatch::ApproximateSize() const { return rep_.size(); }

int WriteBatchInternal::Count(const WriteBatch* b) {
  return DecodeFixed32(b->rep_.data() + 8);
}

void WriteBatchInternal::SetCount(WriteBatch* b, int n) {
  EncodeFixed32(&b->rep_[8], n);
}

SequenceNumber WriteBatchInternal::Sequence(const WriteBatch* b) {
  return SequenceNumber(DecodeFixed64(b->rep_.data()));
}

void WriteBatchInternal::SetSequence(WriteBatch* b, SequenceNumber seq) {
  EncodeFixed64(&b->rep_[0], seq);
}
```

`WriteBatch::rep_` çš„å‰ 12 ä¸ªå­—èŠ‚å®šä¹‰ä¸º Headerï¼Œå­˜å‚¨äº† sequence number å’Œ countã€‚`EncodeFixed` å’Œ `DecodeFixed`ç³»åˆ—å‡½æ•°å®ç°äº†æ•°å€¼åˆ°å­—ç¬¦ä¸²çš„ç¼–è§£ç ï¼Œæœ‰å…´è¶£å¯ä»¥å‰å¾€ [`util/coding.cc`](https://github.com/google/leveldb/blob/master/util/coding.cc) æŸ¥çœ‹å®ç°ï¼Œè¿™é‡Œä¸è¯¦ç»†ä»‹ç»äº†ã€‚æ¥ä¸‹æ¥çœ‹ `Put` å’Œ `Delete` çš„å®ç°ï¼š

```c++
void WriteBatch::Put(const Slice& key, const Slice& value) {
  WriteBatchInternal::SetCount(this, WriteBatchInternal::Count(this) + 1);
  rep_.push_back(static_cast<char>(kTypeValue));
  PutLengthPrefixedSlice(&rep_, key);
  PutLengthPrefixedSlice(&rep_, value);
}

void WriteBatch::Delete(const Slice& key) {
  WriteBatchInternal::SetCount(this, WriteBatchInternal::Count(this) + 1);
  rep_.push_back(static_cast<char>(kTypeDeletion));
  PutLengthPrefixedSlice(&rep_, key);
}

void WriteBatch::Append(const WriteBatch& source) {
  WriteBatchInternal::Append(this, &source);
}

void WriteBatchInternal::SetContents(WriteBatch* b, const Slice& contents) {
  assert(contents.size() >= kHeader);
  b->rep_.assign(contents.data(), contents.size());
}

void WriteBatchInternal::Append(WriteBatch* dst, const WriteBatch* src) {
  SetCount(dst, Count(dst) + Count(src));
  assert(src->rep_.size() >= kHeader);
  dst->rep_.append(src->rep_.data() + kHeader, src->rep_.size() - kHeader);
}
```

`Put` å’Œ `Delete` é¦–å…ˆå°†è®¡æ•°åŠ ä¸€ï¼Œåœ¨ `rep_` ä¸­å†™å…¥æ“ä½œç±»å‹ï¼Œå†å†™å…¥é”®å€¼å¯¹ã€‚`PutLengthPrefixedSlice` å‡½æ•°ä¼šå…ˆå†™å…¥å­—ç¬¦ä¸²çš„é•¿åº¦ï¼Œå†å†™å…¥å­—ç¬¦ä¸²çš„å†…å®¹ã€‚`WriteBatchInternal` çš„èµ‹å€¼å’Œè¿½åŠ å‡æ˜¯å¯¹ `rep_` çš„è¿›è¡Œæ“ä½œã€‚ç»§ç»­çœ‹è¿­ä»£å‡½æ•°å’Œ `Handle` çš„éƒ¨åˆ†ï¼š

```c++
Status WriteBatch::Iterate(Handler* handler) const {
  Slice input(rep_);
  if (input.size() < kHeader) {
    return Status::Corruption("malformed WriteBatch (too small)");
  }

  input.remove_prefix(kHeader);
  Slice key, value;
  int found = 0;
  while (!input.empty()) {
    found++;
    char tag = input[0];
    input.remove_prefix(1);
    switch (tag) {
      case kTypeValue:
        if (GetLengthPrefixedSlice(&input, &key) &&
            GetLengthPrefixedSlice(&input, &value)) {
          handler->Put(key, value);
        } else {
          return Status::Corruption("bad WriteBatch Put");
        }
        break;
      case kTypeDeletion:
        if (GetLengthPrefixedSlice(&input, &key)) {
          handler->Delete(key);
        } else {
          return Status::Corruption("bad WriteBatch Delete");
        }
        break;
      default:
        return Status::Corruption("unknown WriteBatch tag");
    }
  }
  if (found != WriteBatchInternal::Count(this)) {
    return Status::Corruption("WriteBatch has wrong count");
  } else {
    return Status::OK();
  }
}

namespace {
class MemTableInserter : public WriteBatch::Handler {
 public:
  SequenceNumber sequence_;
  MemTable* mem_;

  void Put(const Slice& key, const Slice& value) override {
    mem_->Add(sequence_, kTypeValue, key, value);
    sequence_++;
  }
  void Delete(const Slice& key) override {
    mem_->Add(sequence_, kTypeDeletion, key, Slice());
    sequence_++;
  }
};
}  // namespace

Status WriteBatchInternal::InsertInto(const WriteBatch* b, MemTable* memtable) {
  MemTableInserter inserter;
  inserter.sequence_ = WriteBatchInternal::Sequence(b);
  inserter.mem_ = memtable;
  return b->Iterate(&inserter);
}
```

è¿­ä»£å‡½æ•° `WriteBatch::Iterate` ä¼šæŒ‰ç…§é¡ºåºå°† `rep_` ä¸­å­˜å‚¨çš„é”®å€¼å¯¹æ“ä½œæ”¾åˆ° `hander` ä¸Šæ‰§è¡Œã€‚ä¸‹é¢çš„åŒ¿åç©ºé—´é‡Œå®šä¹‰äº†ä¸€ä¸ªç»§æ‰¿ `Handler` çš„å­ç±» `MemTableInserter`ï¼Œå°† `Put` å’Œ `Delete` è½¬åˆ° `MemTable` ä¸Šæ‰§è¡Œã€‚`MemTable` å³ä¸ºå†…å­˜æ•°æ®åº“ï¼Œæœ¬æ–‡ç¨åä»‹ç»ã€‚`WriteBatchInternal::InsertInto` å°±ç›´æ¥æ ¹æ® `MemTable` æ„é€  `MemTableInserter`ã€‚è¿™æ ·åšçš„å¥½å¤„ï¼Œå¯èƒ½å°±æ˜¯ `WriteBatch::Iterate` ä¸ `MemTable` è§£è€¦ï¼Œ`Handler` å¯ä»¥è‡ªè¡Œæ›¿æ¢ã€‚

ç»¼åˆæ¥çœ‹ï¼Œ`WriteBatch` å°†æ‰€æœ‰çš„ä¿®æ”¹å’Œåˆ é™¤æ“ä½œå‡å­˜å‚¨åˆ°ä¸€ä¸ªå­—ç¬¦ä¸²ä¸­ï¼Œå¹¶ä¸”æä¾›äº†å†…å­˜æ•°æ®åº“çš„è¿­ä»£æ¥å£ã€‚è€Œå•ä¸ªå­—ç¬¦ä¸²ä¹Ÿå¯ä»¥éå¸¸æ–¹ä¾¿åœ°è¿›è¡ŒæŒä¹…åŒ–ï¼Œè¿™ä¸€ç‚¹ä¹Ÿä¼šåœ¨æ—¥å¿—éƒ¨åˆ†æœ‰æ‰€ä½“ç°ã€‚

### 2. æ—¥å¿— Log

åœ¨ `DB::Write` å‡½æ•°ä¸­ï¼Œæ ¸å¿ƒçš„å†™å…¥æ­¥éª¤ä»£ç å¦‚ä¸‹ï¼š

```c++
// Add to log and apply to memtable.  We can release the lock
// during this phase since &w is currently responsible for logging
// and protects against concurrent loggers and concurrent writes
// into mem_.
{
  mutex_.Unlock();
  status = log_->AddRecord(WriteBatchInternal::Contents(updates));
  bool sync_error = false;
  if (status.ok() && options.sync) {
    status = logfile_->Sync();
    if (!status.ok()) {
      sync_error = true;
    }
  }
  if (status.ok()) {
    status = WriteBatchInternal::InsertInto(updates, mem_);
  }
  mutex_.Lock();
  if (sync_error) {
    // The state of the log file is indeterminate: the log record we
    // just added may or may not show up when the DB is re-opened.
    // So we force the DB into a mode where all future writes fail.
    RecordBackgroundError(status);
  }
}
```

å…ˆè¿½åŠ åˆ°æ—¥å¿—ï¼Œå†å†™å…¥å†…å­˜æ•°æ®åº“ã€‚è¿™é‡Œçš„ `log_` ä¸ºæˆå‘˜å˜é‡ï¼Œç±»å‹ä¸º `log::Writer`ï¼Œå…¶å®šä¹‰ä½äº [`db/log_writer.h`](https://github.com/google/leveldb/blob/master/db/log_writer.h)ï¼š

```c++
#include <stdint.h>

#include "db/log_format.h"
#include "leveldb/slice.h"
#include "leveldb/status.h"

namespace leveldb {

class WritableFile;

namespace log {

class Writer {
 public:
  // Create a writer that will append data to "*dest".
  // "*dest" must be initially empty.
  // "*dest" must remain live while this Writer is in use.
  explicit Writer(WritableFile* dest);

  // Create a writer that will append data to "*dest".
  // "*dest" must have initial length "dest_length".
  // "*dest" must remain live while this Writer is in use.
  Writer(WritableFile* dest, uint64_t dest_length);

  Writer(const Writer&) = delete;
  Writer& operator=(const Writer&) = delete;

  ~Writer();

  Status AddRecord(const Slice& slice);

 private:
  Status EmitPhysicalRecord(RecordType type, const char* ptr, size_t length);

  WritableFile* dest_;
  int block_offset_;  // Current offset in block

  // crc32c values for all supported record types.  These are
  // pre-computed to reduce the overhead of computing the crc of the
  // record type stored in the header.
  uint32_t type_crc_[kMaxRecordType + 1];
};

}  // namespace log
}  // namespace leveldb
```

å…¬å¼€çš„æ¥å£åªæœ‰ä¸€ä¸ª `Log::Writer::AddRecord`ï¼Œä¹Ÿå°±æ˜¯ `DB::Write`  ä¸­è°ƒç”¨çš„å‡½æ•°ã€‚å¦å¤–ç±»ä¸­è¿˜æœ‰ä¸€ä¸ªç§æœ‰æ•°ç»„ `type_crc_`ï¼Œå†…éƒ¨å­˜å‚¨äº†é¢„å…ˆè®¡ç®—çš„å‡ ç§ç±»å‹çš„ `CRC32` æ ¡éªŒå€¼ã€‚å¸¸é‡ `kMaxRecordType` å®šä¹‰äº [`db/log_format.h`](https://github.com/google/leveldb/blob/master/db/format.h)ï¼Œè¯¥æ–‡ä»¶å®šä¹‰äº†æ—¥å¿—æ ¼å¼ç›¸å…³çš„å‡ ä¸ªå¸¸é‡ï¼š

```c++
enum RecordType {
  // Zero is reserved for preallocated files
  kZeroType = 0,

  kFullType = 1,

  // For fragments
  kFirstType = 2,
  kMiddleType = 3,
  kLastType = 4
};
static const int kMaxRecordType = kLastType;

static const int kBlockSize = 32768;

// Header is checksum (4 bytes), length (2 bytes), type (1 byte).
static const int kHeaderSize = 4 + 2 + 1;
```

æ—¥å¿—ç±»ä¸­çš„ `AddRecord` å‡½æ•°æ¯æ¬¡è°ƒç”¨ä¼šå¢åŠ ä¸€æ¡è®°å½• Recordï¼ŒåŒæ—¶æˆ‘ä»¬éœ€è¦ä¿è¯ä»¥åå¯ä»¥æŒ‰é¡ºåºè¯»å–å‡ºæ¯ä¸€æ¡ Recordã€‚ä¸ºäº†æå‡æ—¥å¿—çš„è¯»å–é€Ÿåº¦é€Ÿåº¦ï¼ŒLevelDB å¼•å…¥äº† Block çš„æ¦‚å¿µã€‚åœ¨è¯»å†™æ–‡ä»¶æ—¶ä¼šæŒ‰ç…§ä¸€ä¸ªä¸€ä¸ª Block æ¥è¯»å†™ï¼Œé»˜è®¤çš„ Block å¤§å°ä¸º `kBlockSize = 32KB`ã€‚è€Œä¸€æ¡è®°å½•å¯èƒ½æ¯” Block è¿˜è¦é•¿ï¼Œæ‰€ä»¥è¿˜éœ€è¦å¯¹è¿‡é•¿çš„ Record åšåˆé€‚çš„åˆ‡åˆ†ï¼Œåˆ‡æˆç‰‡æ®µ Fragment åå†æ”¾å…¥ Block ä¸­ã€‚Fragment åˆ†ä¸ºä¸‰ç§ç±»å‹ï¼Œåˆ†åˆ«æ˜¯ `kFirstType`ã€`kMiddleType` å’Œ `kLastType`ï¼Œå‚çœ‹ä¸‹å›¾ï¼š

![Log Format](../images/0401845d2d596d0a577fe164ba72f66a.svg)

ç»§ç»­çœ‹ [`db/log_writer.cc`](https://github.com/google/leveldb/blob/master/db/log_writer.cc) çš„å…·ä½“å®ç°ï¼š

```c++
#include "db/log_writer.h"

#include <stdint.h>

#include "leveldb/env.h"
#include "util/coding.h"
#include "util/crc32c.h"

namespace leveldb {
namespace log {

static void InitTypeCrc(uint32_t* type_crc) {
  for (int i = 0; i <= kMaxRecordType; i++) {
    char t = static_cast<char>(i);
    type_crc[i] = crc32c::Value(&t, 1);
  }
}

Writer::Writer(WritableFile* dest) : dest_(dest), block_offset_(0) {
  InitTypeCrc(type_crc_);
}

Writer::Writer(WritableFile* dest, uint64_t dest_length)
    : dest_(dest), block_offset_(dest_length % kBlockSize) {
  InitTypeCrc(type_crc_);
}

Writer::~Writer() = default;

Status Writer::EmitPhysicalRecord(RecordType t, const char* ptr,
                                  size_t length) {
  assert(length <= 0xffff);  // Must fit in two bytes
  assert(block_offset_ + kHeaderSize + length <= kBlockSize);

  // Format the header
  char buf[kHeaderSize];
  buf[4] = static_cast<char>(length & 0xff);
  buf[5] = static_cast<char>(length >> 8);
  buf[6] = static_cast<char>(t);

  // Compute the crc of the record type and the payload.
  uint32_t crc = crc32c::Extend(type_crc_[t], ptr, length);
  crc = crc32c::Mask(crc);  // Adjust for storage
  EncodeFixed32(buf, crc);

  // Write the header and the payload
  Status s = dest_->Append(Slice(buf, kHeaderSize));
  if (s.ok()) {
    s = dest_->Append(Slice(ptr, length));
    if (s.ok()) {
      s = dest_->Flush();
    }
  }
  block_offset_ += kHeaderSize + length;
  return s;
}

}  // namespace log
}  // namespace leveldb
```

æ„é€ æ—¶ `InitTypeCrc` å‡½æ•°åˆå§‹åŒ–äº† `type_crc_` æ•°ç»„ï¼Œå¦å¤–å¦‚æœæ„é€ æ—¶æœ‰ `dest_length` å‚æ•°ï¼Œåˆ™å°† `block_offset_` è®¾ä¸º `dest_length % kBlockSize`ã€‚è‡³äºå‡½æ•° `EmitPhysicalRecord`ï¼Œä»å‡½æ•°åæ¥çœ‹å…¶ä½œç”¨æ˜¯è§¦å‘ç‰©ç†è®°å½•ã€‚è¯¥å‡½æ•°å…ˆæ„é€ äº†ä¸€ä¸ª Record Header `buf`ï¼Œå‰ 4 å­—èŠ‚å­˜å‚¨ CRC32 æ ¡éªŒå€¼ï¼Œåé¢ä¾æ¬¡å­˜å‚¨é•¿åº¦å’Œ Record ç±»å‹ã€‚æœ€ç»ˆä¼šå°† Headerã€å­—èŠ‚æµå†™å…¥æ–‡ä»¶å¹¶åˆ·æ–°ï¼Œå¹¶ä¸”æ›´æ–° `block_offset_`ã€‚æœ€åæ¥çœ‹ä¸‹ `Log::Writer::AddRecord` å‡½æ•°çš„å®ç°ï¼š

```c++
Status Writer::AddRecord(const Slice& slice) {
  const char* ptr = slice.data();
  size_t left = slice.size();

  // Fragment the record if necessary and emit it.  Note that if slice
  // is empty, we still want to iterate once to emit a single
  // zero-length record
  Status s;
  bool begin = true;
  do {
    const int leftover = kBlockSize - block_offset_;
    assert(leftover >= 0);
    if (leftover < kHeaderSize) {
      // Switch to a new block
      if (leftover > 0) {
        // Fill the trailer (literal below relies on kHeaderSize being 7)
        static_assert(kHeaderSize == 7, "");
        dest_->Append(Slice("\x00\x00\x00\x00\x00\x00", leftover));
      }
      block_offset_ = 0;
    }

    // Invariant: we never leave < kHeaderSize bytes in a block.
    assert(kBlockSize - block_offset_ - kHeaderSize >= 0);

    const size_t avail = kBlockSize - block_offset_ - kHeaderSize;
    const size_t fragment_length = (left < avail) ? left : avail;

    RecordType type;
    const bool end = (left == fragment_length);
    if (begin && end) {
      type = kFullType;
    } else if (begin) {
      type = kFirstType;
    } else if (end) {
      type = kLastType;
    } else {
      type = kMiddleType;
    }

    s = EmitPhysicalRecord(type, ptr, fragment_length);
    ptr += fragment_length;
    left -= fragment_length;
    begin = false;
  } while (s.ok() && left > 0);
  return s;
}
```

å‡½æ•°é¦–å…ˆä¼šè®¡ç®—å½“å‰ Block å‰©ä½™ç©ºé—´å¤§å° `leftover`ï¼Œå¦‚æœè¿ Header éƒ½æ²¡æ³•å†™è¿›å»ï¼Œå°±ç›´æ¥å¡«å…… 0 è¿›å»ï¼ŒåæœŸè¯»å–æ—¶ä¼šç›´æ¥è¿‡æ»¤æ‰ã€‚è€Œåè®¡ç®—å¯ç”¨çš„ç©ºé—´å¤§å° `avail` å’Œå½“å‰å†™å…¥çš„é•¿åº¦ `fragment_length` ä»¥åŠå¯¹åº”çš„è®°å½•ç±»å‹ `type`ï¼Œæœ€åè°ƒç”¨ `EmitPhysicalRecord` åˆ·å…¥æ–‡ä»¶ã€‚è¿™ç§æ–¹å¼å¯ä»¥ä¿è¯å†™ Record æ—¶æŒ‰ç…§ `BlockSize` å¯¹é½ã€‚

ç»¼ä¸Šæ¥çœ‹ï¼Œå†™å…¥æ—¶é¦–å…ˆä¼šæŠŠ `WriteBatch::rep_` å¯¹é½åœ°è¿½åŠ åˆ°æ—¥å¿—ä¸­ï¼Œå†™å…¥æ—¶åšäº†åˆé€‚çš„åˆ‡åˆ†ï¼Œå¹¶ä¸”åŠ å…¥äº† CRC æ ¡éªŒã€‚æœ‰å†™è‚¯å®šæœ‰è¯»ï¼Œå½“è¿›è¡Œæ¢å¤æ“ä½œæ—¶å°±ä¼šè¯»å–ä¸Šè¿°æ—¥å¿—ï¼Œ`Log::Reader` ä»£ç å®ç°ä½äº  [`db/log_reader.h`](https://github.com/google/leveldb/blob/master/db/log_reader.h) å’Œ [`db/log_reader.cc`](https://github.com/google/leveldb/blob/master/db/log_reader.cc)ï¼Œè¯»å–çš„è¿‡ç¨‹å³ä¸ºå†™å…¥çš„é€†è¿‡ç¨‹ï¼Œæœ‰å…´è¶£å¯ä»¥è‡ªè¡Œé˜…è¯»ã€‚