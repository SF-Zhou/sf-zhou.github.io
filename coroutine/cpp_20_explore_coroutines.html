<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="shortcut icon" href="/dist/favicon.ico">
    <link rel="apple-touch-icon" href="/dist/favicon.png">
    <link rel="stylesheet" type="text/css" href="/dist/highlight.css">
    <link rel="stylesheet" type="text/css" href="/dist/katex.min.css">
    <link rel="stylesheet" type="text/css" href="/dist/main.css">
    <title>再探 C++20 协程 | SF-Zhou's Blog</title>
  </head>
  <body>
    <div class="app">
      <div class="title">
        <h1> 再探 C++20 协程 </h1>
      </div>
      <div class="info">
        <div class="date"> 2021.04.29 </div>
        <a href="https://github.com/SF-Zhou">
          <div class="author"> SF-Zhou </div>
        </a>
      </div>
      <div class="markdown">
        <p>距上一次<a href="/coroutine/cpp_20_coroutines.html">初探 C++20 协程</a>近一年了，对 C++20 的无栈协程方案有了一些新的认识，写在这里。</p>
<h3 id="1.-方案回顾" tabindex="-1"><a href="#1.-%E6%96%B9%E6%A1%88%E5%9B%9E%E9%A1%BE">1. 方案回顾</a></h3>
<p>C++20 的协程方案中有三个核心的对象：</p>
<ol>
<li><code>promise object</code>，由用户实现，用于在协程内部提交结果或者抛出异常；</li>
<li><code>coroutine handle</code>，无所有权的协程内部状态指针，用于在协程外部恢复协程运行或者执行销毁；</li>
<li><code>coroutine state</code>，协程内部状态，存储 <code>promise object</code>、参数、局部变量以及协程恢复上下文。</li>
</ol>
<p>再看一下官方文档中的样例（<a href="https://godbolt.org/z/8xxEfvqcW">在线执行</a>）：</p>
<pre class="language-cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;coroutine></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdexcept></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread></span></span>

<span class="token keyword">auto</span> <span class="token function">switch_to_new_thread</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>jthread<span class="token operator">&amp;</span> out<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 用于 co_await，需要实现 await_ready/await_suspend/await_resume 的 traits</span>
  <span class="token keyword">struct</span> <span class="token class-name">awaitable</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>jthread<span class="token operator">*</span> p_out<span class="token punctuation">;</span>
    <span class="token keyword">bool</span> <span class="token function">await_ready</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>             <span class="token comment">// 判断是否需要挂起</span>
    <span class="token keyword">void</span> <span class="token function">await_suspend</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>coroutine_handle<span class="token operator">&lt;</span><span class="token operator">></span> h<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 挂起时调用，传入 handle</span>
      std<span class="token double-colon punctuation">::</span>jthread<span class="token operator">&amp;</span> out <span class="token operator">=</span> <span class="token operator">*</span>p_out<span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>out<span class="token punctuation">.</span><span class="token function">joinable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> std<span class="token double-colon punctuation">::</span><span class="token function">runtime_error</span><span class="token punctuation">(</span><span class="token string">"Output jthread parameter not empty"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      out <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">jthread</span><span class="token punctuation">(</span><span class="token punctuation">[</span>h<span class="token punctuation">]</span> <span class="token punctuation">{</span> h<span class="token punctuation">.</span><span class="token function">resume</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 在新的线程恢复协程</span>
      <span class="token comment">// 假设新线程立即执行，恢复协程，则该 awaiter 会立即被销毁，故 p_out 不可用</span>
      <span class="token comment">// Potential undefined behavior: accessing potentially destroyed *this</span>
      <span class="token comment">// std::cout &lt;&lt; "New thread ID: " &lt;&lt; p_out->get_id() &lt;&lt; '\n';</span>
      std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"New thread ID: "</span> <span class="token operator">&lt;&lt;</span> out<span class="token punctuation">.</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>  <span class="token comment">// this is OK</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">void</span> <span class="token function">await_resume</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token comment">// 返回 awaitable 对象</span>
  <span class="token keyword">return</span> awaitable<span class="token punctuation">{</span><span class="token operator">&amp;</span>out<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">struct</span> <span class="token class-name">task</span> <span class="token punctuation">{</span>
  <span class="token comment">// 用户实现的 promise 类</span>
  <span class="token keyword">struct</span> <span class="token class-name">promise_type</span> <span class="token punctuation">{</span>
    task <span class="token function">get_return_object</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token comment">// 协程首次挂起时返回给调用方的对象</span>
    std<span class="token double-colon punctuation">::</span>suspend_never <span class="token function">initial_suspend</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    std<span class="token double-colon punctuation">::</span>suspend_never <span class="token function">final_suspend</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">void</span> <span class="token function">return_void</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token comment">// 协程内部 co_return void 时调用</span>
    <span class="token keyword">void</span> <span class="token function">unhandled_exception</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

task <span class="token function">resuming_on_new_thread</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>jthread<span class="token operator">&amp;</span> out<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 构造 coroutine state 对象，并初始化内部的 promise object，由编译器生成代码</span>
  <span class="token comment">// 调用 co_await promise.initial_suspend()，不挂起，继续执行</span>
  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Coroutine started on thread: "</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>
  <span class="token comment">// 1. 调用 switch_to_new_thread 构造 awaitable 对象</span>
  <span class="token comment">// 2. co_await awaitable，调用 awaitable.await_ready()，返回 false 执行挂起</span>
  <span class="token comment">// 3. 挂起时调用 awaitable.await_suspend()，并且给调用方返回 task 对象</span>
  <span class="token keyword">co_await</span> <span class="token function">switch_to_new_thread</span><span class="token punctuation">(</span>out<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// awaiter destroyed here</span>
  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Coroutine resumed on thread: "</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>
  <span class="token comment">// 调用 co_await promise.final_suspend()，不挂起，继续执行</span>
  <span class="token comment">// 销毁 coroutine state 对象。若 final_suspend 返回 std::suspend_always 则需要用户自行调用 handle.destroy() 进行销毁</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  std<span class="token double-colon punctuation">::</span>jthread out<span class="token punctuation">;</span>
  <span class="token function">resuming_on_new_thread</span><span class="token punctuation">(</span>out<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<h3 id="2.-无栈协程" tabindex="-1"><a href="#2.-%E6%97%A0%E6%A0%88%E5%8D%8F%E7%A8%8B">2. 无栈协程</a></h3>
<p>C++20 协程使用了无栈协程的方案，那么实际执行时协程究竟运行在何处呢？对于这个问题，可以先回忆下栈在程序执行过程中的作用。</p>
<p>当调用某个函数时，调用方会先将当前执行的位置以及函数参数压栈，然后跳转到被调函数的起点，被调函数会根据自身局部变量的使用情况申请栈空间并执行对应的初始化，被调函数执行完成后自行回收栈空间，并跳转回原先调用的位置，栈也恢复了调用前的状态。栈中存储了<strong>恢复位置和局部变量</strong>。根据先进后出、单调增长的特性，每个函数可以根据<strong>栈顶置针和偏移量</strong>确定自身局部变量在栈上的位置。</p>
<p>对有栈协程来说，可以直接申请内存空间并修改栈顶指针实现自定义的栈，可以通过保存所有 called saved 寄存器的方式存储当前的执行状态，包括栈顶置针和恢复位置。当需要切换协程时，恢复寄存器也就恢复了挂起前的执行状态，局部变量依然可以根据栈顶置针和偏移量来确定位置。其优势是完全兼容原先的函数调用约定，劣势是需要根据最坏情况申请足够的栈空间，并且切换协程时会强行切换栈继而破坏 return stack buffer 的跳转预测，在空间时间效率上比不过无栈协程。</p>
<p>对无栈协程来说，协程切换时<strong>不会切换当前的栈</strong>，而是像直接调用函数一样恢复协程，类似下方的样例：</p>
<pre class="language-cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cassert></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span>

<span class="token comment">// void coroutine() {</span>
<span class="token comment">//   std::uint64_t a = 0;</span>
<span class="token comment">//   std::uint64_t b = 0;</span>
<span class="token comment">//   a = 1;</span>
<span class="token comment">//   printf("set a = %lu and yield 1\n", a);</span>
<span class="token comment">//   yield();</span>
<span class="token comment">//</span>
<span class="token comment">//   b = 2;</span>
<span class="token comment">//   printf("set b = %lu and yield 2\n", b);</span>
<span class="token comment">//   yield();</span>
<span class="token comment">//</span>
<span class="token comment">//   printf("a + b = %lu and yield 3\n", a + b);</span>
<span class="token comment">//   yield();</span>
<span class="token comment">// }</span>

<span class="token keyword">struct</span> <span class="token class-name">coroutine</span> <span class="token punctuation">{</span>
  std<span class="token double-colon punctuation">::</span><span class="token keyword">uint32_t</span> state <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span><span class="token keyword">uint64_t</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span><span class="token keyword">uint64_t</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

  <span class="token keyword">void</span> <span class="token function">resume</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">case</span> <span class="token number">0</span><span class="token operator">:</span>
        a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"set a = %lu and yield 1\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
        state <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>

      <span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span>
        b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"set b = %lu and yield 2\n"</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
        state <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>

      <span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"a + b = %lu and yield 3\n"</span><span class="token punctuation">,</span> a <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
        state <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>

      <span class="token keyword">case</span> <span class="token number">3</span><span class="token operator">:</span>
        <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"done"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">auto</span> co <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_unique</span><span class="token generic class-name"><span class="token operator">&lt;</span>coroutine<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  co<span class="token operator">-></span><span class="token function">resume</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"after yield 1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  co<span class="token operator">-></span><span class="token function">resume</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"after yield 2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  co<span class="token operator">-></span><span class="token function">resume</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"after yield 3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  co<span class="token operator">-></span><span class="token function">resume</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>无栈协程中的局部变量存储不再与栈相关，整个函数相当于被可挂起点切分为多个小函数，恢复时只需要在当前栈上调用下一个小函数。这意味着无栈协程需要一段独立的堆内存空间存储自身的局部变量以及运行状态，并且需要一套新的局部变量定位方式，而这些都是由编译器生成的代码来完成的。无栈协程的优势是可以按需申请栈空间，协程切换时仍然是传统函数调用、返回流程，CPU 的跳转预测优化仍然有效。</p>
<h3 id="3.-内存分配" tabindex="-1"><a href="#3.-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D">3. 内存分配</a></h3>
<p>仔细观察协程函数调用的过程，你会发现每一次协程函数的调用都会触发一次堆内存分配（<a href="https://en.cppreference.com/w/cpp/language/coroutines#Heap_allocation">极少数场景下会被编译器优化掉</a>），这对某些高性能低延迟的系统来说是需要进一步优化的。C++20 的协程方案也提供了自定义内存分配释放的接口，可以在 <code>promise_type</code> 中重载 <code>operator new</code> 和 <code>operator delete</code>，类似下方的例子（<a href="https://godbolt.org/z/Kbd9EE4Gb">在线执行</a>）：</p>
<pre class="language-cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;coroutine></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdexcept></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread></span></span>

<span class="token keyword">auto</span> <span class="token function">switch_to_new_thread</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>jthread<span class="token operator">&amp;</span> out<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">awaitable</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>jthread<span class="token operator">*</span> p_out<span class="token punctuation">;</span>
    <span class="token keyword">bool</span> <span class="token function">await_ready</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">void</span> <span class="token function">await_suspend</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>coroutine_handle<span class="token operator">&lt;</span><span class="token operator">></span> h<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      std<span class="token double-colon punctuation">::</span>jthread<span class="token operator">&amp;</span> out <span class="token operator">=</span> <span class="token operator">*</span>p_out<span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>out<span class="token punctuation">.</span><span class="token function">joinable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> std<span class="token double-colon punctuation">::</span><span class="token function">runtime_error</span><span class="token punctuation">(</span><span class="token string">"Output jthread parameter not empty"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      out <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">jthread</span><span class="token punctuation">(</span><span class="token punctuation">[</span>h<span class="token punctuation">]</span> <span class="token punctuation">{</span> h<span class="token punctuation">.</span><span class="token function">resume</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// Potential undefined behavior: accessing potentially destroyed *this</span>
      <span class="token comment">// std::cout &lt;&lt; "New thread ID: " &lt;&lt; p_out->get_id() &lt;&lt; '\n';</span>
      std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"New thread ID: "</span> <span class="token operator">&lt;&lt;</span> out<span class="token punctuation">.</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>  <span class="token comment">// this is OK</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">void</span> <span class="token function">await_resume</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> awaitable<span class="token punctuation">{</span><span class="token operator">&amp;</span>out<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">struct</span> <span class="token class-name">task</span> <span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">promise_type</span> <span class="token punctuation">{</span>
    task <span class="token function">get_return_object</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    std<span class="token double-colon punctuation">::</span>suspend_never <span class="token function">initial_suspend</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    std<span class="token double-colon punctuation">::</span>suspend_never <span class="token function">final_suspend</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">void</span> <span class="token function">return_void</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">void</span> <span class="token function">unhandled_exception</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

    <span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">auto</span> ptr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"alloc %lu %p\n"</span><span class="token punctuation">,</span> size<span class="token punctuation">,</span> ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> ptr<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">void</span> <span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> ptr<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>size_t size<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>
      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"delete %lu %p\n"</span><span class="token punctuation">,</span> size<span class="token punctuation">,</span> ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

task <span class="token function">resuming_on_new_thread</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>jthread<span class="token operator">&amp;</span> out<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Coroutine started on thread: "</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>
  <span class="token keyword">co_await</span> <span class="token function">switch_to_new_thread</span><span class="token punctuation">(</span>out<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// awaiter destroyed here</span>
  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Coroutine resumed on thread: "</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  std<span class="token double-colon punctuation">::</span>jthread out<span class="token punctuation">;</span>
  <span class="token function">resuming_on_new_thread</span><span class="token punctuation">(</span>out<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/*
alloc 64 0x7fa45b505880
Coroutine started on thread: 0x10b219e00
New thread ID: 0x7000034a9000
Coroutine resumed on thread: 0x7000034a9000
delete 64 0x7fa45b505880
*/</span>
</code></pre>
<p>同一个协程函数每次调用时需要申请的堆内存大小是一致的，可以根据这一点设计出高效的内存池。</p>
<h3 id="4.-嵌套调用" tabindex="-1"><a href="#4.-%E5%B5%8C%E5%A5%97%E8%B0%83%E7%94%A8">4. 嵌套调用</a></h3>
<p>理想中的协程应用应该是类似这样的：</p>
<pre class="language-cpp"><code class="language-cpp">Promise<span class="token operator">&lt;</span><span class="token keyword">uint64_t</span><span class="token operator">></span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
Promise<span class="token operator">&lt;</span><span class="token keyword">uint32_t</span><span class="token operator">></span> <span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
Promise<span class="token operator">&lt;</span><span class="token keyword">uint64_t</span><span class="token operator">></span> <span class="token function">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">auto</span> a <span class="token operator">=</span> <span class="token keyword">co_await</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">auto</span> b <span class="token operator">=</span> <span class="token keyword">co_await</span> <span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">co_return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">auto</span> result <span class="token operator">=</span> <span class="token function">block_on</span><span class="token punctuation">(</span><span class="token function">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>换句话说，协程函数返回的 Promise 对象也需要是 Awaitable 的，在 Promise 类中实现 <code>co_await</code> 需要的 traits 即可，类似下面的例子（<a href="https://godbolt.org/z/6fP74o5f9">在线执行</a>）：</p>
<pre class="language-cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;coroutine></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;future></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;queue></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread></span></span>

<span class="token comment">// 简单的定时器</span>
<span class="token keyword">class</span> <span class="token class-name">Timer</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">void</span> <span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">uint32_t</span> timeout<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>coroutine_handle<span class="token operator">&lt;</span><span class="token operator">></span> h<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    tasks<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>Task<span class="token punctuation">{</span><span class="token punctuation">.</span>expire <span class="token operator">=</span> <span class="token function">MsTick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> timeout<span class="token punctuation">,</span> <span class="token punctuation">.</span>coroutine <span class="token operator">=</span> h<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">void</span> <span class="token function">Loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>tasks<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">MsTick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> tasks<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>expire<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        tasks<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>coroutine<span class="token punctuation">.</span><span class="token function">resume</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        tasks<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span><span class="token function">milliseconds</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">static</span> <span class="token keyword">uint64_t</span> <span class="token function">MsTick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">auto</span> now <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>system_clock<span class="token double-colon punctuation">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">time_since_epoch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">duration_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>milliseconds<span class="token operator">></span></span></span><span class="token punctuation">(</span>now<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
  <span class="token keyword">struct</span> <span class="token class-name">Task</span> <span class="token punctuation">{</span>
    <span class="token keyword">uint64_t</span> expire<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>coroutine_handle<span class="token operator">&lt;</span><span class="token operator">></span> coroutine<span class="token punctuation">;</span>
    <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token keyword">const</span> Task<span class="token operator">&amp;</span> other<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> expire <span class="token operator">></span> other<span class="token punctuation">.</span>expire<span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span>priority_queue<span class="token operator">&lt;</span>Task<span class="token operator">></span> tasks<span class="token punctuation">;</span>
<span class="token punctuation">}</span> timer<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Sleeper</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">Sleeper</span><span class="token punctuation">(</span><span class="token keyword">uint32_t</span> timeout<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">timeout_</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  <span class="token keyword">bool</span> <span class="token function">await_ready</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token keyword">void</span> <span class="token function">await_resume</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword">void</span> <span class="token function">await_suspend</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>coroutine_handle<span class="token operator">&lt;</span><span class="token operator">></span> h<span class="token punctuation">)</span> <span class="token punctuation">{</span> timer<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>timeout_<span class="token punctuation">,</span> h<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
  <span class="token keyword">uint32_t</span> timeout_<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Promise</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">struct</span> <span class="token class-name">promise_type</span> <span class="token punctuation">{</span>
    Promise <span class="token function">get_return_object</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">Promise</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">auto</span> <span class="token function">initial_suspend</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> std<span class="token double-colon punctuation">::</span>suspend_never<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">auto</span> <span class="token function">final_suspend</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> std<span class="token double-colon punctuation">::</span>suspend_never<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">void</span> <span class="token function">unhandled_exception</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span><span class="token function">terminate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">void</span> <span class="token function">return_void</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 子协程结束时唤醒父协程继续执行</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        parent<span class="token punctuation">.</span><span class="token function">resume</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    std<span class="token double-colon punctuation">::</span>coroutine_handle<span class="token operator">&lt;</span><span class="token operator">></span> parent<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token function">Promise</span><span class="token punctuation">(</span>promise_type<span class="token operator">*</span> promise<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">promise_</span><span class="token punctuation">(</span>promise<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  <span class="token comment">// 当前协程结束才能返回 ready</span>
  <span class="token keyword">bool</span> <span class="token function">await_ready</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> std<span class="token double-colon punctuation">::</span><span class="token class-name">coroutine_handle</span><span class="token operator">&lt;</span>promise_type<span class="token operator">></span><span class="token double-colon punctuation">::</span><span class="token function">from_promise</span><span class="token punctuation">(</span><span class="token operator">*</span>promise_<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">void</span> <span class="token function">await_resume</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token comment">// 父协程需要挂起时在子协程中注册一个结束的回调函数用以唤醒</span>
  <span class="token keyword">void</span> <span class="token function">await_suspend</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>coroutine_handle<span class="token operator">&lt;</span><span class="token operator">></span> h<span class="token punctuation">)</span> <span class="token punctuation">{</span> promise_<span class="token operator">-></span>parent <span class="token operator">=</span> h<span class="token punctuation">;</span> <span class="token punctuation">}</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
  promise_type<span class="token operator">*</span> promise_<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

Promise <span class="token function">Sleep</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token keyword">uint32_t</span> msec<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">co_await</span> <span class="token function">Sleeper</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

Promise <span class="token function">CoroutineFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">uint32_t</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">co_await</span> <span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">co_await</span> <span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"await 500ms * 2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">CoroutineFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  timer<span class="token punctuation">.</span><span class="token function">Loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>显然，协程的使用具有传染性，如果在子函数中使用了协程，那么整个应用的调用链路上基本都需要启用协程。Golang 原生全局支持协程，而 Rust 中类似 Tokio 的框架也推荐直接在 <code>main</code> 函数中启用协程环境：</p>
<pre class="language-rust"><code class="language-rust"><span class="token attribute attr-name">#[tokio::main]</span>
<span class="token keyword">async</span> <span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// transform into</span>
<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> rt <span class="token operator">=</span> <span class="token namespace">tokio<span class="token punctuation">::</span>runtime<span class="token punctuation">::</span></span><span class="token class-name">Runtime</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    rt<span class="token punctuation">.</span><span class="token function">block_on</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">{</span>
        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
<h3 id="references" tabindex="-1"><a href="#references">References</a></h3>
<ol>
<li><a href="https://en.cppreference.com/w/cpp/language/coroutines">&quot;Coroutines (C++20)&quot;, <em>C++ Reference</em></a></li>
<li><a href="https://www.zhihu.com/question/65647171/answer/233495694">&quot;async/await异步模型是否优于stackful coroutine模型？&quot;, <em>圆珠笔的回答 - 知乎</em></a></li>
<li><a href="https://stackoverflow.com/questions/57163510/are-stackless-c20-coroutines-a-problem">&quot;Are stackless C++20 coroutines a problem?&quot;, <em>StackOverflow</em></a></li>
</ol>

      </div>
      <script src="https://utteranc.es/client.js" repo="SF-Zhou/sf-zhou.github.io" issue-term="title" label="Comment" theme="preferred-color-scheme" crossorigin="anonymous" async> </script>
      <div class="footer">
        <div class="license">
          Except where otherwise noted, content on this site is licensed under a <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> license.
        </div>
        <div class="copyright">
          Copyright©2017 SF-Zhou, All Rights Reserved. Powered by <a href="https://pages.github.com/">GitHub Pages</a> and <a href="https://github.com/features/actions">GitHub Actions</a>.
        </div>
      </div>
    </div>
    <script src="/dist/main.js"></script>
    <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','https://www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-61723712-2', 'auto'); ga('send', 'pageview'); </script>
  </body>
</html>
