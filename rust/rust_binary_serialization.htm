<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="shortcut icon" href="/dist/favicon.ico">
    <link rel="apple-touch-icon" href="/dist/favicon.png">
    <link rel="stylesheet" type="text/css" href="/dist/highlight.css">
    <link rel="stylesheet" type="text/css" href="/dist/katex.min.css">
    <link rel="stylesheet" type="text/css" href="/dist/main.css">
    <title>Rust 二进制序列化 | SF-Zhou's Blog</title>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-GQ26H3JQ3G"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-GQ26H3JQ3G');
    </script>
  </head>
  <body>
    <div class="app">
      <div class="title">
        <h1> Rust 二进制序列化 </h1>
      </div>
      <div class="info">
        <div class="date"> 2024.07.19 </div>
        <a href="https://github.com/SF-Zhou">
          <div class="author"> SF-Zhou </div>
        </a>
      </div>
      <div class="markdown">
        <p>最近在做 Rust RDMA RPC 框架，需要一套二进制序列化库。因为对 Rust 编程中的范型和宏不是太熟悉，所以刚好自己做一套用以练手。本文简述一下该序列化库的设计方案。</p>
<h3 id="1.-二进制格式" tabindex="-1"><a href="#1.-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%A0%BC%E5%BC%8F">1. 二进制格式</a></h3>
<p>序列化的二进制格式参考我原先做的 C++ 库，大概原则是这样的：</p>
<ol>
<li>所有字段仅保留值，不记录类型信息，不进行任何对齐操作；</li>
<li>数值直接使用小端存储；</li>
<li>String/Vec 先序列化其长度，再序列化具体内容；</li>
<li>各类长度信息使用 VarInt 存储以减少长度；</li>
<li>对结构体，先序列化整个序列化结果的长度，再依次序列化所有字段。</li>
</ol>
<p>反序列化时，则按顺序反序列化即可。举例：</p>
<pre class="language-rust"><code class="language-rust"><span class="token keyword">struct</span> <span class="token type-definition class-name">A</span> <span class="token punctuation">{</span>
  x<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span>
  y<span class="token punctuation">:</span> <span class="token keyword">i32</span>
<span class="token punctuation">}</span>

<span class="token keyword">struct</span> <span class="token type-definition class-name">B</span> <span class="token punctuation">{</span>
  a<span class="token punctuation">:</span> <span class="token class-name">A</span><span class="token punctuation">,</span>
  b<span class="token punctuation">:</span> <span class="token keyword">u64</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token comment">// 以下是一个 B 类型对象的序列化结果</span>
data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0x1a</span><span class="token punctuation">,</span> <span class="token number">0x11</span><span class="token punctuation">,</span> <span class="token number">0x0c</span><span class="token punctuation">,</span> <span class="token number">0x68</span><span class="token punctuation">,</span> <span class="token number">0x65</span><span class="token punctuation">,</span> <span class="token number">0x6c</span><span class="token punctuation">,</span> <span class="token number">0x6c</span><span class="token punctuation">,</span> <span class="token number">0x6f</span><span class="token punctuation">,</span> <span class="token number">0x20</span><span class="token punctuation">,</span> <span class="token number">0x77</span><span class="token punctuation">,</span> <span class="token number">0x6f</span><span class="token punctuation">,</span> <span class="token number">0x72</span><span class="token punctuation">,</span> <span class="token number">0x6c</span><span class="token punctuation">,</span> <span class="token number">0x64</span><span class="token punctuation">,</span> <span class="token number">0x21</span><span class="token punctuation">,</span> <span class="token number">0x20</span><span class="token punctuation">,</span> <span class="token number">0x00</span><span class="token punctuation">,</span> <span class="token number">0x00</span><span class="token punctuation">,</span> <span class="token number">0x00</span><span class="token punctuation">,</span> <span class="token number">0xe9</span><span class="token punctuation">,</span> <span class="token number">0x00</span><span class="token punctuation">,</span> <span class="token number">0x00</span><span class="token punctuation">,</span> <span class="token number">0x00</span><span class="token punctuation">,</span> <span class="token number">0x00</span><span class="token punctuation">,</span> <span class="token number">0x00</span><span class="token punctuation">,</span> <span class="token number">0x00</span><span class="token punctuation">,</span> <span class="token number">0x00</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

data <span class="token operator">=</span> <span class="token punctuation">[</span>
  <span class="token number">0x1a</span><span class="token punctuation">,</span> <span class="token comment">// B 类型各个字段序列化的总长度为 26</span>
    <span class="token comment">// 第一个字段：结构体 a</span>
    <span class="token number">0x11</span><span class="token punctuation">,</span> <span class="token comment">// A 类型各个字段序列化的总长度为 17</span>
      <span class="token comment">// 第一个字段：String</span>
      <span class="token number">0x0c</span><span class="token punctuation">,</span> <span class="token comment">// 字符串的长度为 12</span>
        <span class="token comment">// 解析字符串，得到 hello world</span>
        <span class="token number">0x68</span><span class="token punctuation">,</span> <span class="token number">0x65</span><span class="token punctuation">,</span> <span class="token number">0x6c</span><span class="token punctuation">,</span> <span class="token number">0x6c</span><span class="token punctuation">,</span> <span class="token number">0x6f</span><span class="token punctuation">,</span> <span class="token number">0x20</span><span class="token punctuation">,</span> <span class="token number">0x77</span><span class="token punctuation">,</span> <span class="token number">0x6f</span><span class="token punctuation">,</span> <span class="token number">0x72</span><span class="token punctuation">,</span> <span class="token number">0x6c</span><span class="token punctuation">,</span> <span class="token number">0x64</span><span class="token punctuation">,</span> <span class="token number">0x21</span><span class="token punctuation">,</span>
      <span class="token comment">// 第二个字段：i32</span>
      <span class="token number">0x20</span><span class="token punctuation">,</span> <span class="token number">0x00</span><span class="token punctuation">,</span> <span class="token number">0x00</span><span class="token punctuation">,</span> <span class="token number">0x00</span><span class="token punctuation">,</span> <span class="token comment">// 小端解析得到数字 32</span>
    <span class="token comment">// 第二个字段：u64</span>
    <span class="token number">0xe9</span><span class="token punctuation">,</span> <span class="token number">0x00</span><span class="token punctuation">,</span> <span class="token number">0x00</span><span class="token punctuation">,</span> <span class="token number">0x00</span><span class="token punctuation">,</span> <span class="token number">0x00</span><span class="token punctuation">,</span> <span class="token number">0x00</span><span class="token punctuation">,</span> <span class="token number">0x00</span><span class="token punctuation">,</span> <span class="token number">0x00</span><span class="token punctuation">,</span> <span class="token comment">// 小端解析得到数字 233</span>
<span class="token punctuation">]</span>
</code></pre>
<h3 id="2.-定义和实现" tabindex="-1"><a href="#2.-%E5%AE%9A%E4%B9%89%E5%92%8C%E5%AE%9E%E7%8E%B0">2. 定义和实现</a></h3>
<p>实现这样的序列化似乎并不复杂：</p>
<ol>
<li>对数值来说，可以直接调用 <code>&amp;x.to_le_bytes()</code> 获得 <code>&amp;[u8]</code></li>
<li>对字符串来说，可以直接调用 <code>x.as_bytes()</code> 获得 <code>&amp;[u8]</code></li>
<li>对于结构体，按顺序将每个字符转为 <code>&amp;[u8]</code>，拼接上长度即可</li>
<li>对于类似 <code>Vec&lt;Item&gt;</code> 这样的容器，按顺序将每个 <code>Item</code> 转为 <code>&amp;[u8]</code> 即可</li>
</ol>
<p>所以需要一个容器，用以存储序列化的结果。并且该容器最好是可以用户自定义的，故这里定义一个 <code>Serializier</code> 的 trait 用以表征承载序列化结果的容器。考虑上一节中提到的第 5 条，因为结构体序列化的长度是记录在最前方的，而该长度又是变长的，我们无法在序列化完成前轻松地获得该长度，所以需要先序列化所有字段，再序列化该长度。所以 <code>Serializier</code> 的定义如下：</p>
<pre class="language-rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">trait</span> <span class="token type-definition class-name">Serializer</span> <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function-definition function">prepend</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">,</span> data<span class="token punctuation">:</span> <span class="token keyword">impl</span> <span class="token class-name">AsRef</span><span class="token operator">&lt;</span><span class="token punctuation">[</span><span class="token keyword">u8</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">Result</span><span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">;</span>
    <span class="token keyword">fn</span> <span class="token function-definition function">len</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">usize</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>对于序列化操作本身，定义一个 <code>Serialize</code> 的 trait：</p>
<pre class="language-rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">trait</span> <span class="token type-definition class-name">Serialize</span> <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function-definition function">serialize</span><span class="token operator">&lt;</span><span class="token class-name">S</span><span class="token punctuation">:</span> <span class="token class-name">Serializer</span> <span class="token operator">+</span> <span class="token class-name">Default</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">Result</span><span class="token operator">&lt;</span><span class="token class-name">S</span><span class="token operator">></span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> <span class="token keyword">mut</span> serializer <span class="token operator">=</span> <span class="token class-name">S</span><span class="token punctuation">::</span><span class="token function">default</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">serialize_to</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> serializer<span class="token punctuation">)</span><span class="token operator">?</span><span class="token punctuation">;</span>
        <span class="token class-name">Ok</span><span class="token punctuation">(</span>serializer<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">fn</span> <span class="token function-definition function">serialize_to</span><span class="token operator">&lt;</span><span class="token class-name">S</span><span class="token punctuation">:</span> <span class="token class-name">Serializer</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> serializer<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token class-name">S</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">Result</span><span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>

      </div>
      
      <div class="footer">
        <div class="license">
          Except where otherwise noted, content on this site is licensed under a <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> license.
        </div>
        <div class="copyright">
          Copyright©2017 SF-Zhou, All Rights Reserved. Powered by <a href="https://pages.github.com/">GitHub Pages</a> and <a href="https://github.com/features/actions">GitHub Actions</a>.
        </div>
      </div>
    </div>
    <script src="/dist/main.js"></script>
  </body>
</html>
